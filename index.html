<!-- /mnt/data/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>IXFM Decline Curve Generator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0f172a; --card:#111827; --muted:#94a3b8; --text:#e5e7eb; --brand:#22c55e; --accent:#3b82f6; --danger:#ef4444; --border:#1f2937; --slb:#003366; --amber:#eab308; --green:#22c55e; }
    * { box-sizing:border-box }
    body { margin:0; font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial; background:var(--bg); color:var(--text) }
    header { padding:14px 16px; display:flex; gap:10px; flex-wrap:wrap; align-items:center; border-bottom:1px solid var(--border); position:sticky; top:0; background: linear-gradient(180deg, var(--slb) 0%, #012a52 100%); color:#fff; z-index:2; }
    .brandwrap { display:flex; flex-direction:column; margin-right:8px }
    .title { font-size:18px; font-weight:700; line-height:1.1 }
    .subtitle { font-size:12px; opacity:.9 }
    .btn { padding:8px 12px; border:1px solid rgba(255,255,255,.2); border-radius:10px; background:rgba(255,255,255,.06); color:#fff; cursor:pointer; font-weight:600; font-size:12px }
    .btn:hover { background:rgba(255,255,255,.1) }
    .btn.brand { background:#16a34a; border-color:#0e7a34; color:#052e16 }
    .btn.danger { background:var(--danger); border-color:#991b1b; color:#fff }
    .btn.dark { background:#0b1220; border-color:#2a364d; color:#e5e7eb }
    .hint { color:#e5e7eb; opacity:.85; font-size:11px }
    .tabs { display:flex; flex-wrap:wrap; gap:6px; row-gap:8px; padding:10px 16px; margin-top:28px; border-bottom:1px solid var(--border); background:#0e1527; overflow:visible; }
    .tab { display:flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid var(--border); background:var(--card); border-radius:10px; cursor:pointer; white-space:nowrap; font-size:12px }
    .tab.active { outline:2px solid var(--accent) }
    .tab input { background:transparent; color:#e5e7eb; border:none; width:120px; font-weight:600; font-size:12px }
    .tab .x { font-weight:800; color:#94a3b8; cursor:pointer }
    .wrap { padding:16px; display:flex; justify-content:center }
    .container { width:100%; max-width:980px; }
    .card { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:12px }
    .controls { display:flex; gap:12px; align-items:center; justify-content:space-between; margin-bottom:10px; flex-wrap:wrap; font-size:12px }
    .right { display:flex; gap:8px; align-items:center; flex-wrap:wrap }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace }
    .units { display:grid; grid-template-columns: repeat(6, minmax(120px, 1fr)); gap:8px; margin:10px 0 6px }
    .units label { display:flex; flex-direction:column; gap:4px; font-size:11px; color:var(--muted) }
    select, input[type="number"] { background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:8px; padding:6px 8px; font-size:12px }
    input[type="number"] { width:72px }
    table { width:100%; border-collapse:collapse; table-layout:fixed }
    thead th { position:sticky; top:0; background:#0b1220; z-index:1 }
    th,td { border:1px solid #1f2937; padding:6px; text-align:left; vertical-align:top; font-size:12px; line-height:1.2 }
    td[contenteditable="true"] { outline:none }
    td:focus { box-shadow: inset 0 0 0 2px var(--accent) }
    .plot-title { font-size:12px; color:var(--muted); margin-bottom:8px }
    .plot-wrap { width:100%; overflow:auto }
    .plot-empty { font-size:12px; color:var(--muted); padding:8px }
    .diag { font-size:12px; color:#eab308; }
    .diag .ok { color:#22c55e }
    .diag .bad { color:#f87171 }
    .diag ul { margin:6px 0 0 18px; padding:0 }
    .legend { display:flex; gap:12px; align-items:center; margin-top:6px; font-size:11px; color:#cbd5e1; flex-wrap:wrap }
    .legend .item { display:flex; gap:6px; align-items:center }
    .chip { width:14px; height:3px; border-radius:2px; display:inline-block }
    .export { display:flex; align-items:center; gap:8px }
    .export label { font-size:11px; opacity:.9 }
  </style>
</head>
<body>
  <header>
    <div class="brandwrap">
      <div class="title">IXFM Decline Curve Generator</div>
      <div class="subtitle">Prototype Version</div>
    </div>
    <button class="btn dark" id="addWellBtn">+ Add Well</button>
    <div class="export">
      <label class="hint">Export:</label>
      <select id="exportMode">
        <option value="anchored" selected>Anchored (max at t0)</option>
        <option value="unanchored">Unanchored (best exp/hyp)</option>
      </select>
    </div>
    <button class="btn brand" id="downloadBtn">Download JSON</button>
    <button class="btn danger" id="deleteAllBtn">Delete All Wells</button>
    <span class="hint">Tip: paste from Excel; rows auto-expand.</span>
  </header>

  <div class="tabs" id="tabs"></div>

  <div class="wrap">
    <div class="container">
      <div class="card">
        <div class="controls">
          <div class="mono">Active: <span id="activeWellName"></span></div>
          <div class="right">
            <label class="hint">Copies</label>
            <input id="copyCount" type="number" min="1" step="1" value="1" />
            <button class="btn dark" id="duplicateBtn">Duplicate</button>
            <button class="btn dark" id="clearDataBtn">Clear Data</button>
            <button class="btn danger" id="deleteWellBtn">Delete Well</button>
          </div>
        </div>

        <div class="units">
          <label>
            Time Unit
            <select id="u_time">
              <option value="d">days</option>
              <option value="h">hours</option>
              <option value="mo30">months (30 d)</option>
              <option value="y365">years (365 d)</option>
            </select>
          </label>
          <label>
            Block P Unit
            <select id="u_bp">
              <option value="kpa">kPa</option>
              <option value="bar">bar</option>
              <option value="mpa">MPa</option>
              <option value="psi">psi</option>
            </select>
          </label>
          <label>
            BHP Unit
            <select id="u_bhp">
              <option value="kpa">kPa</option>
              <option value="bar">bar</option>
              <option value="mpa">MPa</option>
              <option value="psi">psi</option>
            </select>
          </label>
          <label>
            Oil Rate Unit
            <select id="u_oil">
              <option value="m3d">m³/day</option>
              <option value="stbd">STB/day</option>
              <option value="m3h">m³/hour</option>
            </select>
          </label>
          <label>
            Gas Rate Unit
            <select id="u_gas">
              <option value="m3d">m³/day</option>
              <option value="mscf">MSCF/day</option>
              <option value="mmscf">MMSCF/day</option>
            </select>
          </label>
          <label>
            Water Rate Unit
            <select id="u_wat">
              <option value="m3d">m³/day</option>
              <option value="stbd">STB/day</option>
              <option value="m3h">m³/hour</option>
            </select>
          </label>
        </div>

        <div style="overflow:auto;">
          <table>
            <thead>
              <tr>
                <th>Time</th>
                <th>Well Block Pressure - 9P</th>
                <th>Bottom-hole Pressure</th>
                <th>Oil Rate</th>
                <th>Gas Rate</th>
                <th>Water Rate</th>
              </tr>
            </thead>
            <tbody id="tableBody"></tbody>
          </table>
        </div>
      </div>

      <div class="card" style="margin-top:12px;">
        <div class="legend mono">
          <div class="item"><span class="chip" style="background:#3b82f6"></span>Raw</div>
          <div class="item"><span class="chip" style="background:#eab308"></span>Anchored Fit</div>
          <div class="item"><span class="chip" style="background:#22c55e"></span>Unanchored Fit</div>
          <div class="item"><span class="chip" style="background:#64748b"></span>Export mode → <span id="legendExportMode">Anchored</span></div>
        </div>
      </div>

      <div class="card" style="margin-top:12px;">
        <div class="plot-title mono">Intercept (q @ pwf=0) vs Days — STB/day</div>
        <div class="plot-wrap">
          <svg id="plotIntercept" width="100%" height="280" viewBox="0 0 900 280" preserveAspectRatio="none"></svg>
          <div id="emptyIntercept" class="plot-empty" style="display:none;">Enter at least two valid rows (Time, BP, BHP, Oil).</div>
        </div>
      </div>

      <div class="card" style="margin-top:12px;">
        <div class="plot-title mono">IPR (Productivity Index) vs Days — STB/(day.psi)</div>
        <div class="plot-wrap">
          <svg id="plotPI" width="100%" height="280" viewBox="0 0 900 280" preserveAspectRatio="none"></svg>
          <div id="emptyPI" class="plot-empty" style="display:none;">Enter at least two valid rows (Time, BP, BHP, Oil).</div>
        </div>
      </div>

      <div class="card" style="margin-top:12px;">
        <div class="plot-title mono">IPR vs Intercept — Scatter (Raw vs Fits)</div>
        <div class="plot-wrap">
          <svg id="plotPIvsInt" width="100%" height="300" viewBox="0 0 900 300" preserveAspectRatio="none"></svg>
          <div id="emptyPIvsInt" class="plot-empty" style="display:none;">Enter at least two valid rows (Time, BP, BHP, Oil).</div>
        </div>
      </div>

      <div class="card" style="margin-top:12px;">
        <div class="plot-title mono">Diagnostics — Sanity Checks (Darcy IPR)</div>
        <div class="diag" id="diagBox">
          <span class="ok">No issues yet.</span>
        </div>
      </div>
    </div>
  </div>

<script>
/** Constants & state */
const WELL_COLS = ["Time","Well Block Pressure - 9P","Bottom-hole Pressure","Oil Rate","Gas Rate","Water Rate"];

/* Keep these EXACT for export */
const SERIES_META = {
  OIL_PRODUCTION_CUML: { description:"Oil production cumulative rate", displayUnit:"STB", measurementID:"Liquid_Production_Volume" },
  GAS_OIL_RATIO: { description:"Gas Oil Ratio", displayUnit:"MSCF/STB", measurementID:"Gas_To_Liquid_Ratio" },
  WATER_CUT: { description:"Water Cut", displayUnit:"STB/STB", measurementID:"Liquid_To_Liquid_Ratio" },
  INTERCEPT_OIL_PHASE_IPR_REF_DEPTH: { description:"Oil phase IPR intercept", displayUnit:"STB/day", measurementID:"Liquid_Flowrate" },
  SCALING_FACTOR_OIL_PHASE_IPR_REF_DEPTH: { description:"Oil phase IPR scaling factor", displayUnit:"STB/(day.psi)", measurementID:"Liquid_Productivity_Index" }
};

/* Unit factors */
const M3_TO_STB = 6.28981077;
const STB_TO_M3 = 1 / M3_TO_STB;
/* Correct: m³ → MMSCF = 35.3146667 / 1,000,000 */
const M3_TO_MMSCF = 3.53146667e-5 / 1000;

const PSI_TO_KPA = 6.894757293168;
const BAR_TO_KPA = 100.0;
const MPA_TO_KPA = 1000.0;

let wells = [];
let activeWellId = null;
let exportMode = 'anchored';

/** DOM refs */
const tabsEl = document.getElementById('tabs');
const bodyEl = document.getElementById('tableBody');
const addWellBtn = document.getElementById('addWellBtn');
const exportModeSel = document.getElementById('exportMode');
const legendExportMode = document.getElementById('legendExportMode');
const downloadBtn = document.getElementById('downloadBtn');
const deleteAllBtn = document.getElementById('deleteAllBtn');
const deleteWellBtn = document.getElementById('deleteWellBtn');
const clearDataBtn = document.getElementById('clearDataBtn');
const duplicateBtn = document.getElementById('duplicateBtn');
const copyCountInput = document.getElementById('copyCount');
const activeWellNameEl = document.getElementById('activeWellName');
const u_time = document.getElementById('u_time');
const u_bp = document.getElementById('u_bp');
const u_bhp = document.getElementById('u_bhp');
const u_oil = document.getElementById('u_oil');
const u_gas = document.getElementById('u_gas');
const u_wat = document.getElementById('u_wat');
const svgIntercept = document.getElementById('plotIntercept');
const svgPI = document.getElementById('plotPI');
const svgPIvsInt = document.getElementById('plotPIvsInt');
const emptyIntercept = document.getElementById('emptyIntercept');
const emptyPI = document.getElementById('emptyPI');
const emptyPIvsInt = document.getElementById('emptyPIvsInt');
const diagBox = document.getElementById('diagBox');

/** Helpers */
const uuid = () => Math.random().toString(36).slice(2,9);
const toNumber = v => {
  if (typeof v === 'number') return v;
  if (v == null) return NaN;
  const s = String(v).trim().replace(/,/g,'');
  if (s === '') return NaN;
  const n = Number(s);
  return Number.isFinite(n) ? n : NaN;
};
const isMostlyNonNumericRow = row => row.map(toNumber).filter(Number.isFinite).length <= 2;
function ensureRows(well, rowsNeeded) { const add = Math.max(0, rowsNeeded - well.tableData.length); for (let i=0;i<add;i++) well.tableData.push(Array(WELL_COLS.length).fill('')); return add; }
function isWellEmpty(well) { for (const row of well.tableData) for (const cell of row) if (String(cell ?? '').trim() !== '') return false; return true; }
function nextAvailableWellName() {
  const used = new Set(); for (const w of wells) { const m = /^P(\d+)$/.exec(w.name.trim()); if (m) used.add(Number(m[1])); }
  let n = 1; while (used.has(n)) n++; return `P${n}`;
}

/** Units */
function factorTimeToDays(code){ switch(code){ case 'd': return 1; case 'h': return 1/24; case 'mo30': return 30; case 'y365': return 365; default: return 1; } }
function factorPressureToKPa(code){ switch(code){ case 'kpa': return 1; case 'bar': return BAR_TO_KPA; case 'mpa': return MPA_TO_KPA; case 'psi': return PSI_TO_KPA; default: return 1; } }
function factorOilWaterToM3d(code){ switch(code){ case 'm3d': return 1; case 'stbd': return STB_TO_M3; case 'm3h': return 24; default: return 1; } }
function factorGasToM3d(code){ switch(code){ case 'm3d': return 1; case 'mscf': return 28.316846592; case 'mmscf': return 28316.846592; default: return 1; } }
function applyFactorArray(arr, factor){ return arr.map(v => Number.isFinite(v) ? v*factor : NaN); }

/** Tabs & wells */
function defaultUnits(){ return { time:'d', bp:'kpa', bhp:'kpa', oil:'m3d', gas:'m3d', wat:'m3d' }; }
function createWell(name){ return { id: uuid(), name, units: defaultUnits(), tableData: Array.from({length:30}, () => Array(WELL_COLS.length).fill('')) }; }
function addWell(initialName) { const name = initialName ?? `P${wells.length+1}`; const well = createWell(name); wells.push(well); setActiveWell(well.id); renderTabs(); renderTable(); renderUnits(); safeRenderAll(); }
function deleteWell(id) { wells = wells.filter(w=>w.id!==id); if (!wells.length) addWell('P1'); setActiveWell(wells[0].id); renderTabs(); renderTable(); renderUnits(); safeRenderAll(); }
function deleteWellWithMaybeConfirm(id) { const w = wells.find(x=>x.id===id); if (!w) return; if (isWellEmpty(w)) { deleteWell(id); } else { if (confirm(`Delete well "${w.name}"?`)) deleteWell(id); } }
function resetAllWells() { wells = []; addWell('P1'); }
function setActiveWell(id) { activeWellId = id; activeWellNameEl.textContent = wells.find(w=>w.id===id)?.name ?? ''; }
function renameWell(id,newName) { const w = wells.find(x=>x.id===id); if (!w) return; w.name = newName.trim() || w.name; if (id===activeWellId) activeWellNameEl.textContent = w.name; }
function renderTabs() {
  const tabsElLoc = tabsEl;
  tabsElLoc.innerHTML = '';
  wells.forEach(w=>{
    const tab=document.createElement('div');
    tab.className='tab'+(w.id===activeWellId?' active':''); 
    tab.onclick=()=>{ setActiveWell(w.id); renderTabs(); renderTable(); renderUnits(); safeRenderAll(); };
    const input=document.createElement('input'); input.value=w.name; input.oninput=e=>renameWell(w.id,e.target.value);
    const close=document.createElement('span'); close.className='x'; close.textContent='×'; close.onclick=(ev)=>{ ev.stopPropagation(); deleteWellWithMaybeConfirm(w.id); };
    tab.appendChild(input); tab.appendChild(close); tabsElLoc.appendChild(tab);
  });
}

/** Table */
function renderTable() {
  const w = wells.find(x=>x.id===activeWellId); if (!w) return;
  bodyEl.innerHTML='';
  w.tableData.forEach((row,r)=>{
    const tr=document.createElement('tr');
    for (let c=0;c<WELL_COLS.length;c++){
      const td=document.createElement('td');
      td.contentEditable='true'; td.spellcheck=false;
      td.dataset.row=r; td.dataset.col=c;
      td.textContent=row[c] ?? '';
      td.addEventListener('input', onCellInput);
      td.addEventListener('paste', onCellPaste);
      tr.appendChild(td);
    }
    bodyEl.appendChild(tr);
  });
}
function onCellInput(e){
  const td=e.currentTarget; const r=+td.dataset.row, c=+td.dataset.col;
  const w=wells.find(x=>x.id===activeWellId);
  w.tableData[r][c]=td.textContent;
  safeRenderAll();
}
function onCellPaste(e){
  e.preventDefault();
  const td=e.currentTarget; const startR=+td.dataset.row, startC=+td.dataset.col;
  const raw=(e.clipboardData||window.clipboardData).getData('text');
  const lines=raw.replace(/\r/g,'').split('\n').filter(Boolean).map(l=>l.split('\t'));
  if (!lines.length) return;
  const payload=isMostlyNonNumericRow(lines[0])?lines.slice(1):lines;
  const w=wells.find(x=>x.id===activeWellId);
  const added=ensureRows(w, startR+payload.length);
  if (added>0) renderTable();
  for (let i=0;i<payload.length;i++){
    const cols=payload[i];
    for (let j=0;j<cols.length && (startC+j)<WELL_COLS.length;j++){
      const r=startR+i, c=startC+j;
      w.tableData[r][c]=cols[j];
      const cell=bodyEl.querySelector(`td[data-row="${r}"][data-col="${c}"]`);
      if (cell) cell.textContent=cols[j];
    }
  }
  safeRenderAll();
}

/** Math utils */
function safeDiv(a,b){ return (Number.isFinite(a)&&Number.isFinite(b)&&Math.abs(b)>0)?(a/b):NaN; }
function cumsum(arr){ const out=[]; let s=0; for (const v of arr){ const x=Number.isFinite(v)?v:0; s+=x; out.push(s) } return out; }
function median(arr){ const v=arr.filter(Number.isFinite).slice().sort((a,b)=>a-b); const n=v.length; if(!n) return NaN; const m=Math.floor(n/2); return n%2? v[m] : 0.5*(v[m-1]+v[m]); }

/** OLS for PI vs Intercept (scatter only) */
function olsYonX(xs, ys){
  let n=0, sx=0, sy=0, sxx=0, sxy=0;
  for (let i=0;i<xs.length;i++){
    const x=xs[i], y=ys[i];
    if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
    n++; sx+=x; sy+=y; sxx+=x*x; sxy+=x*y;
  }
  const denom = n*sxx - sx*sx;
  if (n<2 || Math.abs(denom)<1e-12) return null;
  const m = (n*sxy - sx*sy) / denom;
  const b = (sy - m*sx) / n;
  return { m, b };
}

/** Decline fits */
function fitExpDecay(T, Y){
  const t=[], lnY=[];
  for (let i=0;i<T.length;i++){
    const ti=T[i], yi=Y[i];
    if (Number.isFinite(ti) && Number.isFinite(yi) && yi>0){ t.push(ti); lnY.push(Math.log(yi)); }
  }
  const n=t.length; if (n<2) return null;
  let sx=0, sxx=0, sy=0, sxy=0;
  for (let i=0;i<n;i++){ const x=t[i], y=lnY[i]; sx+=x; sxx+=x*x; sy+=y; sxy+=x*y; }
  const denom = (n*sxx - sx*sx);
  if (Math.abs(denom) < 1e-12) return null;
  const c = (n*sxy - sx*sy) / denom;
  const a = (sy - c*sx) / n;
  let A = Math.exp(a);
  let b = -c;
  if (!Number.isFinite(A) || A<=0) return null;
  if (!Number.isFinite(b) || b<=0) b = 1e-8;
  const predict = (ti)=> Math.max(0, A * Math.exp(-b * Math.max(0,ti)));
  let sse=0;
  for (let i=0;i<n;i++){ const e = (predict(t[i]) - Math.exp(lnY[i])); sse += e*e; }
  const k=2; const aic = n>0 ? (n*Math.log((sse/n)||1e-18) + 2*k) : Infinity;
  return { type:'exp', A, b, predict, sse, n, aic };
}
function fitHyperbolic(T, Y){
  const t=[], y=[];
  for (let i=0;i<T.length;i++){
    const ti=T[i], yi=Y[i];
    if (Number.isFinite(ti) && Number.isFinite(yi) && yi>0){ t.push(Math.max(0,ti)); y.push(yi); }
  }
  const npts = t.length;
  if (npts < 3) return null;

  const tmax = Math.max(...t);
  const tspan = Math.max(1e-9, tmax);
  const logspace = (a,b,k)=>{ const out=[]; const la=Math.log(a), lb=Math.log(b); for (let i=0;i<k;i++){ const u=i/(k-1); out.push(Math.exp(la + (lb-la)*u)); } return out; };

  const nCand = [0.3,0.5,0.7,1.0,1.2,1.5];
  const bCand = logspace(1e-6, 10/tspan, 18);

  let best=null;
  for (const n of nCand){
    for (const b of bCand){
      let sumBy=0, sumB2=0;
      for (let i=0;i<npts;i++){
        const base = 1/Math.pow(1 + b*t[i], n);
        sumBy += base * y[i];
        sumB2 += base * base;
      }
      let A = (sumB2>0) ? (sumBy / sumB2) : 0;
      if (!Number.isFinite(A) || A<=0) continue;
      let sse=0;
      for (let i=0;i<npts;i++){
        const yi = A / Math.pow(1 + b*t[i], n);
        const e = yi - y[i];
        sse += e*e;
      }
      if (!best || sse < best.sse){
        const predict = (ti)=> Math.max(0, A / Math.pow(1 + b*Math.max(0,ti), n));
        const k=3;
        const aic = npts>0 ? (npts*Math.log((sse/npts)||1e-18) + 2*k) : Infinity;
        best = { type:'hyperbolic', A, b, n, predict, sse, n:npts, aic };
      }
    }
  }
  return best;
}
/* Anchored helpers */
function sumsXY(xs, ys){
  let n=0, sx2=0, sxy=0;
  for (let i=0;i<xs.length;i++){
    const x=xs[i], y=ys[i];
    if (Number.isFinite(x) && Number.isFinite(y)){ n++; sx2+=x*x; sxy+=x*y; }
  }
  return { n, sx2, sxy };
}
function fitExpAnchored(A0, T, Y, t0){
  const x=[], z=[];
  for (let i=0;i<T.length;i++){
    const yi = Y[i], ti = T[i];
    if (Number.isFinite(ti) && Number.isFinite(yi) && yi>0){
      const dx = Math.max(0, ti - t0);
      x.push(dx);
      z.push(Math.log(A0/yi));
    }
  }
  const S = sumsXY(x, z);
  if (S.n < 2 || S.sx2 <= 0) return null;
  let b = S.sxy / S.sx2;
  if (!Number.isFinite(b) || b <= 0) b = 1e-8;
  const predict = (t) => Math.max(0, A0 * Math.exp(-b * Math.max(0, t - t0)));
  let sse=0, n=0;
  for (let i=0;i<T.length;i++){
    const yi = Y[i], ti = T[i];
    if (Number.isFinite(yi) && Number.isFinite(ti)){
      const e = predict(ti) - yi; sse += e*e; n++;
    }
  }
  const k=1;
  const aic = n>0 ? (n*Math.log((sse/n)||1e-18) + 2*k) : Infinity;
  return { type:'exp', A:A0, b, t0, predict, sse, n, aic };
}
function fitHypAnchored(A0, T, Y, t0){
  const tOff = T.map(t => Number.isFinite(t) ? Math.max(0, t - t0) : NaN);
  const valid = []; for (let i=0;i<T.length;i++){ if (Number.isFinite(tOff[i]) && Number.isFinite(Y[i]) && Y[i]>0) valid.push(i); }
  if (valid.length < 3) return null;

  const tspan = Math.max(1e-9, Math.max(...valid.map(i => tOff[i])));
  const logspace = (a,b,k)=>{ const out=[]; const la=Math.log(a), lb=Math.log(b); for (let i=0;i<k;i++){ const u=i/(k-1); out.push(Math.exp(la + (lb-la)*u)); } return out; };
  const nCand = [0.3,0.5,0.7,1.0,1.2,1.5];
  const bCand = logspace(1e-6, 10/tspan, 18);

  let best = null;
  for (const n of nCand){
    for (const b of bCand){
      let sse = 0, npts=0;
      for (const i of valid){
        const ti = tOff[i];
        const yi = Y[i];
        const yhat = A0 / Math.pow(1 + b*ti, n);
        const e = yhat - yi;
        sse += e*e; npts++;
      }
      if (!best || sse < best.sse){
        const predict = (t) => Math.max(0, A0 / Math.pow(1 + b*Math.max(0, t - t0), n));
        const k=2;
        const aic = npts>0 ? (npts*Math.log((sse/npts)||1e-18) + 2*k) : Infinity;
        best = { type:'hyperbolic', A:A0, b, n, t0, predict, sse, n:npts, aic };
      }
    }
  }
  return best;
}
function enforceNonIncreasing(arr){
  const out = arr.slice();
  for (let i=1;i<out.length;i++){
    if (!Number.isFinite(out[i-1])) continue;
    if (!Number.isFinite(out[i])) { out[i]=out[i-1]; continue; }
    if (out[i] > out[i-1]) out[i] = out[i-1];
    if (out[i] < 0) out[i] = 0;
  }
  return out;
}

/** Core computation */
function computeWellSeriesPhysical(well){
  const data = well.tableData;
  const DAYS_raw = data.map(r=>toNumber(r[0]));
  const BP_raw   = data.map(r=>toNumber(r[1]));
  const BHP_raw  = data.map(r=>toNumber(r[2]));
  const OIL_raw  = data.map(r=>toNumber(r[3]));
  const GAS_raw  = data.map(r=>toNumber(r[4]));
  const WAT_raw  = data.map(r=>toNumber(r[5]));

  let L = DAYS_raw.length;
  for (; L>0; L--){
    const i=L-1;
    if ([DAYS_raw[i],BP_raw[i],BHP_raw[i],OIL_raw[i],GAS_raw[i],WAT_raw[i]].some(v=>Number.isFinite(v))) break;
  }
  if (L===0) return null;

  const fTime = factorTimeToDays(well.units.time);
  const fBP = factorPressureToKPa(well.units.bp);
  const fBHP = factorPressureToKPa(well.units.bhp);
  const fOil = factorOilWaterToM3d(well.units.oil);
  const fGas = factorGasToM3d(well.units.gas);
  const fWat = factorOilWaterToM3d(well.units.wat);

  const Days = applyFactorArray(DAYS_raw.slice(0,L), fTime);
  const BP_kPa = applyFactorArray(BP_raw.slice(0,L), fBP);
  const BHP_kPa = applyFactorArray(BHP_raw.slice(0,L), fBHP);
  const OIL_m3d = applyFactorArray(OIL_raw.slice(0,L), fOil);
  const GAS_m3d = applyFactorArray(GAS_raw.slice(0,L), fGas);
  const WAT_m3d = applyFactorArray(WAT_raw.slice(0,L), fWat);

  const oil_stb = OIL_m3d.map(v=>Number.isFinite(v)? Math.max(0, v*M3_TO_STB) : NaN);
  const wat_stb = WAT_m3d.map(v=>Number.isFinite(v)? Math.max(0, v*M3_TO_STB) : NaN);
  const gas_mmscf = GAS_m3d.map(v=>Number.isFinite(v)? Math.max(0, v*M3_TO_MMSCF) : NaN);
  const BP_psi = BP_kPa.map(v=>Number.isFinite(v)? v/PSI_TO_KPA : NaN);
  const BHP_psi = BHP_kPa.map(v=>Number.isFinite(v)? v/PSI_TO_KPA : NaN);

  const GOR = oil_stb.map((o,i)=>safeDiv(gas_mmscf[i], o));
  const WATER_FRAC = oil_stb.map((o,i)=>{
    const w = wat_stb[i];
    const denom = (Number.isFinite(o)?o:0) + (Number.isFinite(w)?w:0);
    return denom > 0 ? safeDiv(w, denom) : NaN;
  });

  const dDays = Days.map(v=>Number.isFinite(v)?v:0);
  for (let i=dDays.length-1;i>=1;i--) dDays[i] = (Number.isFinite(Days[i])?Days[i]:0) - (Number.isFinite(Days[i-1])?Days[i-1]:0);
  const oilVolPerDate = oil_stb.map((q,i)=>(Number.isFinite(q)?q:0) * (Number.isFinite(dDays[i])?dDays[i]:0));
  const CumOil = cumsum(oilVolPerDate);

  const dP = BP_psi.map((bp,i)=>{
    const pwf = BHP_psi[i];
    return (Number.isFinite(bp) && Number.isFinite(pwf)) ? Math.max(0, bp - pwf) : NaN;
  });

  let PI = oil_stb.map((q,i)=> {
    const dp = dP[i];
    const val = safeDiv(q, dp);
    return Number.isFinite(val) ? Math.max(0, val) : NaN;
  });
  if (PI.length >= 2 && !Number.isFinite(PI[0]) && Number.isFinite(PI[1])) PI[0] = PI[1];

  let INTERCEPT_DARCY = PI.map((pi,i)=>{
    const bp = BP_psi[i];
    const val = (Number.isFinite(pi) && Number.isFinite(bp)) ? (pi * bp) : NaN;
    return Number.isFinite(val) ? Math.max(0, val) : NaN;
  });
  if (INTERCEPT_DARCY.length>=2 && !Number.isFinite(INTERCEPT_DARCY[0]) && Number.isFinite(INTERCEPT_DARCY[1])) {
    INTERCEPT_DARCY[0] = INTERCEPT_DARCY[1];
  }

  const intVals = INTERCEPT_DARCY.filter(v=>Number.isFinite(v) && v>=0);
  const piVals  = PI.filter(v=>Number.isFinite(v) && v>=0);
  const IntAnchor = intVals.length ? Math.max(...intVals) : 0;
  const PIAnchor  = piVals.length ? Math.max(...piVals) : 0;

  let t0 = 0; for (let i=0;i<Days.length;i++){ if (Number.isFinite(Days[i])) { t0 = Days[i]; break; } }

  const T = [], I = [];
  for (let i=0;i<INTERCEPT_DARCY.length;i++){
    const t=Days[i], y=INTERCEPT_DARCY[i];
    if (Number.isFinite(t) && Number.isFinite(y) && y>0){ T.push(t); I.push(y); }
  }
  const Tpi = [], Ypi = [];
  for (let i=0;i<PI.length;i++){
    const t=Days[i], y=PI[i];
    if (Number.isFinite(t) && Number.isFinite(y) && y>0){ Tpi.push(t); Ypi.push(y); }
  }

  /* Anchored Intercept */
  let fitIntExp = (IntAnchor>0 && T.length>=2) ? fitExpAnchored(IntAnchor, T, I, t0) : null;
  let fitIntHyp = (IntAnchor>0 && T.length>=3) ? fitHypAnchored(IntAnchor, T, I, t0) : null;
  let chosenIntA = null;
  if (fitIntExp && fitIntHyp) chosenIntA = (fitIntHyp.aic <= fitIntExp.aic) ? fitIntHyp : fitIntExp;
  else chosenIntA = fitIntHyp || fitIntExp;

  let InterceptA = new Array(Days.length).fill(NaN);
  if (chosenIntA){
    for (let i=0;i<Days.length;i++){ const t=Days[i]; InterceptA[i] = Number.isFinite(t) ? chosenIntA.predict(t) : NaN; }
  } else {
    InterceptA = INTERCEPT_DARCY.slice();
  }
  InterceptA = enforceNonIncreasing(InterceptA);
  if (InterceptA.length) InterceptA[0] = IntAnchor;

  /* Unanchored Intercept */
  let InterceptU = new Array(Days.length).fill(NaN);
  if (T.length>=2){
    const fExp = fitExpDecay(T,I);
    const fHyp = fitHyperbolic(T,I);
    let chosen = null;
    if (fExp && fHyp) chosen = (fHyp.aic <= fExp.aic) ? fHyp : fExp; else chosen = fHyp || fExp;
    if (chosen){
      for (let i=0;i<Days.length;i++){ const t=Days[i]; InterceptU[i] = Number.isFinite(t) ? chosen.predict(t) : NaN; }
      InterceptU = enforceNonIncreasing(InterceptU);
    } else { InterceptU = enforceNonIncreasing(INTERCEPT_DARCY.slice()); }
  } else { InterceptU = enforceNonIncreasing(INTERCEPT_DARCY.slice()); }

  /* Anchored PI */
  let chosenPIA = null;
  if (PIAnchor>0 && Tpi.length>=2){
    if (chosenIntA && chosenIntA.type === 'exp'){
      chosenPIA = fitExpAnchored(PIAnchor, Tpi, Ypi, t0);
    } else {
      chosenPIA = fitHypAnchored(PIAnchor, Tpi, Ypi, t0) || fitExpAnchored(PIAnchor, Tpi, Ypi, t0);
    }
  }
  let PIA = new Array(Days.length).fill(NaN);
  if (chosenPIA){
    for (let i=0;i<Days.length;i++){ const t=Days[i]; PIA[i] = Number.isFinite(t) ? chosenPIA.predict(t) : NaN; }
  } else {
    const scale = (IntAnchor>0) ? (PIAnchor/IntAnchor) : 0;
    for (let i=0;i<Days.length;i++){ PIA[i] = Number.isFinite(InterceptA[i]) ? Math.max(0, scale * InterceptA[i]) : NaN; }
  }
  PIA = enforceNonIncreasing(PIA);
  if (PIA.length) PIA[0] = PIAnchor;

  /* Unanchored PI — direct fit */
  let PIU = new Array(Days.length).fill(NaN);
  if (Tpi.length>=2){
    const fExpPI = fitExpDecay(Tpi, Ypi);
    const fHypPI = fitHyperbolic(Tpi, Ypi);
    let bestPI = null;
    if (fExpPI && fHypPI) bestPI = (fHypPI.aic <= fExpPI.aic) ? fHypPI : fExpPI; else bestPI = fHypPI || fExpPI;
    if (bestPI){
      for (let i=0;i<Days.length;i++){ const t=Days[i]; PIU[i] = Number.isFinite(t) ? bestPI.predict(t) : NaN; }
    } else {
      const medPI = median(Ypi.filter(Number.isFinite));
      PIU = Days.map(()=> Math.max(0, medPI || 0));
    }
  }
  PIU = enforceNonIncreasing(PIU);

  const sanitize = a => a.map(v=>Number.isFinite(v)?v:0);

  return {
    name: well.name.replace(/\./g,''),
    length: L,
    OIL_PRODUCTION_CUML: sanitize(CumOil),
    GAS_OIL_RATIO: sanitize(GOR),
    WATER_CUT: sanitize(WATER_FRAC),
    INTERCEPT_A: sanitize(InterceptA),
    PI_A: sanitize(PIA),
    INTERCEPT_U: sanitize(InterceptU),
    PI_U: sanitize(PIU),
    __plot: {
      Days,
      InterceptDarcy: INTERCEPT_DARCY.slice(),
      InterceptA: InterceptA.slice(),
      InterceptU: InterceptU.slice(),
      PI: PI.slice(),
      PIA: PIA.slice(),
      PIU: PIU.slice(),
      BP_psi: BP_psi.slice(),
      BHP_psi: BHP_psi.slice(),
      q_stbd: oil_stb.slice()
    }
  };
}

/** Post-processing helper: force last to zero (export only) */
function enforceLastZero(arr){
  if (!arr || !arr.length) return arr;
  const out = arr.slice();
  out[out.length - 1] = 0; // why: align with requested post-processing convention
  return out;
}

/** Export JSON (Anchored/Unanchored) */
function buildJson(){
  const payload = { name:"IPR Decline Curves", series:[], step:{}, unitSystem:"ECLIPSE_FIELD", version:"v1", exportMode };
  for (const w of wells){
    const c = computeWellSeriesPhysical(w);
    if (!c) continue;
    payload.step[c.name] = Array.from({length:c.length}, (_,i)=>i);

    const pick = (exportMode === 'anchored')
      ? { INT: c.INTERCEPT_A, PI: c.PI_A }
      : { INT: c.INTERCEPT_U, PI: c.PI_U };

    /* Apply post-processing requirement */
    const INT_pp = enforceLastZero(pick.INT);
    const PI_pp  = enforceLastZero(pick.PI);

    /* Non-IPR series (unchanged) */
    const baseOrder = [
      ["OIL_PRODUCTION_CUML","Oil production cumulative", c.OIL_PRODUCTION_CUML, "STB", "Liquid_Production_Volume"],
      ["GAS_OIL_RATIO","Gas oil ratio", c.GAS_OIL_RATIO, "MSCF/STB", "Gas_To_Liquid_Ratio"],
      ["WATER_CUT","Water cut", c.WATER_CUT, "STB/STB", "Liquid_To_Liquid_Ratio"]
    ];
    for (const [key, desc, arr, unit, mid] of baseOrder){
      payload.series.push({
        description: desc,
        displayUnit: unit,
        entityName: c.name,
        entityType: "WELL",
        measurementID: mid,
        name: key,
        values: arr.slice()
      });
    }

    /* IPR series — EXACT metadata preserved + last=0 */
    const iprOrder = [
      ["INTERCEPT_OIL_PHASE_IPR_REF_DEPTH", INT_pp],
      ["SCALING_FACTOR_OIL_PHASE_IPR_REF_DEPTH", PI_pp]
    ];
    for (const [key, arr] of iprOrder){
      const meta = SERIES_META[key];
      payload.series.push({
        description: meta.description,
        displayUnit: meta.displayUnit,
        entityName: c.name,
        entityType: "WELL",
        measurementID: meta.measurementID,
        name: key,
        values: arr.slice()
      });
    }
  }
  return payload;
}
function download(filename, obj){
  const blob=new Blob([JSON.stringify(obj,null,2)],{type:"application/json"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download=filename; document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}

/** Duplicate */
function duplicateActiveWell(copies) {
  const src = wells.find(x=>x.id===activeWellId);
  if (!src) return;
  const count = Math.max(1, Math.floor(copies || 1));
  for (let i=0;i<count;i++) {
    const name = nextAvailableWellName();
    const id = uuid();
    const tableCopy = src.tableData.map(row => row.slice());
    const unitsCopy = { ...src.units };
    wells.push({ id, name, tableData: tableCopy, units: unitsCopy });
  }
  renderTabs(); safeRenderAll();
}

/** Plotting */
function clearSVG(svg){ while (svg.firstChild) svg.removeChild(svg.firstChild); }
function makeSVG(tag){ return document.createElementNS('http://www.w3.org/2000/svg', tag); }

function renderLineMulti(svg, seriesList, {xLabel, yLabel, emptyEl}){
  clearSVG(svg);
  const allPts = seriesList.flatMap(s=>s.pts);
  if (!allPts.length || allPts.length < 2) { if (emptyEl) emptyEl.style.display='block'; return; }
  if (emptyEl) emptyEl.style.display='none';

  const wBox = svg.viewBox.baseVal.width || 900, hBox = svg.viewBox.baseVal.height || 280;
  const margin = {left:60, right:16, top:16, bottom:36};
  const W = wBox - margin.left - margin.right;
  const H = hBox - margin.top - margin.bottom;

  const xMin = 0;
  const xMax = Math.max(...allPts.map(p=>p[0])) || 1;
  const yMin = 0;
  const yMaxRaw = Math.max(...allPts.map(p=>p[1])) || 1;
  const yMax = (yMaxRaw<=0?1:yMaxRaw*1.1);

  const xMap = x => margin.left + (xMax===xMin?0:((x-xMin)/(xMax-xMin)))*W;
  const yMap = y => margin.top + H - (yMax===yMin?0:((y-yMin)/(yMax-yMin)))*H;

  const axes = makeSVG('g');
  const xAxis = makeSVG('line'); xAxis.setAttribute('x1', margin.left); xAxis.setAttribute('y1', margin.top+H); xAxis.setAttribute('x2', margin.left+W); xAxis.setAttribute('y2', margin.top+H); xAxis.setAttribute('stroke', '#2f3b52'); axes.appendChild(xAxis);
  const yAxis = makeSVG('line'); yAxis.setAttribute('x1', margin.left); yAxis.setAttribute('y1', margin.top); yAxis.setAttribute('x2', margin.left); yAxis.setAttribute('y2', margin.top+H); yAxis.setAttribute('stroke', '#2f3b52'); axes.appendChild(yAxis);

  const xticks=5, yticks=5;
  for (let i=0;i<=xticks;i++){
    const v = xMin + (i/xticks)*(xMax-xMin);
    const x = xMap(v);
    const t = makeSVG('line'); t.setAttribute('x1',x); t.setAttribute('y1',margin.top+H); t.setAttribute('x2',x); t.setAttribute('y2',margin.top+H+6); t.setAttribute('stroke','#2f3b52'); axes.appendChild(t);
    const lbl = makeSVG('text'); lbl.setAttribute('x',x); lbl.setAttribute('y',margin.top+H+20); lbl.setAttribute('text-anchor','middle'); lbl.setAttribute('font-size','11'); lbl.setAttribute('fill','#94a3b8'); lbl.textContent = (Math.round(v*100)/100).toString(); axes.appendChild(lbl);
  }
  for (let i=0;i<=yticks;i++){
    const v = yMin + (i/yticks)*(yMax-yMin);
    const y = yMap(v);
    const t = makeSVG('line'); t.setAttribute('x1',margin.left-6); t.setAttribute('y1',y); t.setAttribute('x2',margin.left); t.setAttribute('y2',y); t.setAttribute('stroke','#2f3b52'); axes.appendChild(t);
    const g = makeSVG('line'); g.setAttribute('x1',margin.left); g.setAttribute('y1',y); g.setAttribute('x2',margin.left+W); g.setAttribute('y2',y); g.setAttribute('stroke','#1f2937'); axes.appendChild(g);
    const lbl = makeSVG('text'); lbl.setAttribute('x',margin.left-8); lbl.setAttribute('y',y+4); lbl.setAttribute('text-anchor','end'); lbl.setAttribute('font-size','11'); lbl.setAttribute('fill','#94a3b8'); lbl.textContent = Math.round(v).toString(); axes.appendChild(lbl);
  }

  const xlab = makeSVG('text'); xlab.setAttribute('x', margin.left+W/2); xlab.setAttribute('y', margin.top+H+32); xlab.setAttribute('text-anchor','middle'); xlab.setAttribute('font-size','12'); xlab.setAttribute('fill','#cbd5e1'); xlab.textContent = xLabel; axes.appendChild(xlab);
  const ylab = makeSVG('text'); ylab.setAttribute('x', 12); ylab.setAttribute('y', margin.top+H/2); ylab.setAttribute('transform', `rotate(-90 12 ${margin.top+H/2})`); ylab.setAttribute('text-anchor','middle'); ylab.setAttribute('font-size','12'); ylab.setAttribute('fill','#cbd5e1'); ylab.textContent = yLabel; axes.appendChild(ylab);

  svg.appendChild(axes);

  for (const s of seriesList){
    if (!s.pts.length) continue;
    const d = s.pts.map((p,i)=>`${i?'L':'M'} ${xMap(p[0])} ${yMap(p[1])}`).join(' ');
    const path = makeSVG('path');
    path.setAttribute('d', d);
    path.setAttribute('fill','none');
    path.setAttribute('stroke', s.color || '#3b82f6');
    path.setAttribute('stroke-width','2');
    if (s.dash) path.setAttribute('stroke-dasharray', s.dash);
    svg.appendChild(path);
  }
}

function renderScatterMulti(svg, seriesList, {xLabel, yLabel, emptyEl}){
  clearSVG(svg);
  const allPts = seriesList.flatMap(s=>s.pts);
  if (!allPts.length || allPts.length < 2) { if (emptyEl) emptyEl.style.display='block'; return; }
  if (emptyEl) emptyEl.style.display='none';

  const wBox = svg.viewBox.baseVal.width || 900, hBox = svg.viewBox.baseVal.height || 300;
  const margin = {left:70, right:16, top:16, bottom:42};
  const W = wBox - margin.left - margin.right;
  const H = hBox - margin.top - margin.bottom;

  const xMin = 0, xMax = Math.max(...allPts.map(p=>p[0])) || 1;
  const yMin = 0, yMax = Math.max(...allPts.map(p=>p[1])) || 1;
  const xMap = x => margin.left + (xMax===xMin?0:((x-xMin)/(xMax-xMin)))*W;
  const yMap = y => margin.top + H - (yMax===yMin?0:((y-yMin)/(yMax-yMin)))*H;

  const axes = makeSVG('g');
  const xAxis = makeSVG('line'); xAxis.setAttribute('x1',margin.left); xAxis.setAttribute('y1',margin.top+H); xAxis.setAttribute('x2',margin.left+W); xAxis.setAttribute('y2',margin.top+H); xAxis.setAttribute('stroke','#2f3b52'); axes.appendChild(xAxis);
  const yAxis = makeSVG('line'); yAxis.setAttribute('x1',margin.left); yAxis.setAttribute('y1',margin.top); yAxis.setAttribute('x2',margin.left); yAxis.setAttribute('y2',margin.top+H); yAxis.setAttribute('stroke','#2f3b52'); axes.appendChild(yAxis);

  const xticks=5, yticks=5;
  for (let i=0;i<=xticks;i++){
    const v = xMin + (i/xticks)*(xMax-xMin);
    const x = xMap(v);
    const t = makeSVG('line'); t.setAttribute('x1',x); t.setAttribute('y1',margin.top+H); t.setAttribute('x2',x); t.setAttribute('y2',margin.top+H+6); t.setAttribute('stroke','#2f3b52'); axes.appendChild(t);
    const lbl = makeSVG('text'); lbl.setAttribute('x',x); lbl.setAttribute('y',margin.top+H+24); lbl.setAttribute('text-anchor','middle'); lbl.setAttribute('font-size','11'); lbl.setAttribute('fill','#94a3b8'); lbl.textContent = Math.round(v).toString(); axes.appendChild(lbl);
  }
  for (let i=0;i<=yticks;i++){
    const v = yMin + (i/yticks)*(yMax-yMin);
    const y = yMap(v);
    const t = makeSVG('line'); t.setAttribute('x1',margin.left-6); t.setAttribute('y1',y); t.setAttribute('x2',margin.left); t.setAttribute('y2',y); t.setAttribute('stroke','#2f3b52'); axes.appendChild(t);
    const g = makeSVG('line'); g.setAttribute('x1',margin.left); g.setAttribute('y1',y); g.setAttribute('x2',margin.left+W); g.setAttribute('y2',y); g.setAttribute('stroke','#1f2937'); axes.appendChild(g);
    const lbl = makeSVG('text'); lbl.setAttribute('x',margin.left-8); lbl.setAttribute('y',y+4); lbl.setAttribute('text-anchor','end'); lbl.setAttribute('font-size','11'); lbl.setAttribute('fill','#94a3b8'); lbl.textContent = (Math.round(v*1000)/1000).toString(); axes.appendChild(lbl);
  }

  const xlab = makeSVG('text'); xlab.setAttribute('x', margin.left+W/2); xlab.setAttribute('y', margin.top+H+36); xlab.setAttribute('text-anchor','middle'); xlab.setAttribute('font-size','12'); xlab.setAttribute('fill','#cbd5e1'); xlab.textContent = xLabel; axes.appendChild(xlab);
  const ylab = makeSVG('text'); ylab.setAttribute('x', 14); ylab.setAttribute('y', margin.top+H/2); ylab.setAttribute('transform', `rotate(-90 14 ${margin.top+H/2})`); ylab.setAttribute('text-anchor','middle'); ylab.setAttribute('font-size','12'); ylab.setAttribute('fill','#cbd5e1'); ylab.textContent = yLabel; axes.appendChild(ylab);

  svg.appendChild(axes);

  for (const s of seriesList){
    for (const [xv,yv] of s.pts){
      if (!Number.isFinite(xv) || !Number.isFinite(yv)) continue;
      const c = makeSVG('circle');
      c.setAttribute('cx', xMap(xv));
      c.setAttribute('cy', yMap(yv));
      c.setAttribute('r', 3.2);
      c.setAttribute('fill', s.color || '#3b82f6');
      svg.appendChild(c);
    }
  }
}

/** Diagnostics */
function buildDiagnostics(plot){
  const msgs = [];
  const tolRel = 0.05;
  const {Days, InterceptDarcy, PI, BP_psi, BHP_psi, q_stbd} = plot;

  for (let i=0;i<Days.length;i++){
    const day = Days[i];
    const bp = BP_psi[i], bhp = BHP_psi[i];
    const q = q_stbd[i], pi = PI[i], itc = InterceptDarcy[i];
    if (![bp,bhp,q].every(Number.isFinite)) continue;

    const dp = Math.max(0, bp - bhp);
    if (bp < bhp) msgs.push(`t=${day}: BP < BHP → Δp<0 (check pressures).`);

    if (Number.isFinite(pi) && Number.isFinite(bp) && Number.isFinite(itc)){
      const expect = pi*bp, denom = Math.max(1, Math.abs(itc));
      const rel = Math.abs(itc - expect) / denom;
      if (rel > tolRel) msgs.push(`t=${day}: Intercept mismatch (>5%). I=${itc.toFixed(2)}, PI*BP=${expect.toFixed(2)}.`);
    }

    if (Number.isFinite(q) && Number.isFinite(itc) && q > itc*(1+tolRel))
      msgs.push(`t=${day}: q (${q.toFixed(2)}) > Intercept (${itc.toFixed(2)}).`);

    if (dp < 1e-6 && q > 0) msgs.push(`t=${day}: Δp≈0 but q>0 (check BHP/BP).`);

    if ((!Number.isFinite(pi) || pi===0) && q>0 && dp>0)
      msgs.push(`t=${day}: PI≈0 but q>0 and Δp>0 (check units).`);
  }
  return msgs;
}

/** Render all outputs */
function renderAllPlotsAndDiag(){
  const w = wells.find(x=>x.id===activeWellId);
  clearSVG(svgIntercept); clearSVG(svgPI); clearSVG(svgPIvsInt);
  if (!w) return;

  const comp = computeWellSeriesPhysical(w);
  if (!comp || !comp.__plot) {
    emptyIntercept.style.display='block';
    emptyPI.style.display='block';
    emptyPIvsInt.style.display='block';
    diagBox.innerHTML = `<span class="ok">No issues yet.</span>`;
    return;
  }

  const X = comp.__plot.Days || [];
  const YintD = comp.__plot.InterceptDarcy || [];
  const YintA = comp.__plot.InterceptA || [];
  const YintU = comp.__plot.InterceptU || [];
  const Ypi = comp.__plot.PI || [];
  const YpiA = comp.__plot.PIA || [];
  const YpiU = comp.__plot.PIU || [];

  const ptsIntD = [], ptsIntA = [], ptsIntU = [];
  const ptsPI = [], ptsPIA = [], ptsPIU = [];
  const ptsScatterRaw = [], ptsFitScatterA = [], ptsFitScatterU = [];

  for (let i=0;i<X.length; i++){
    const x = X[i];
    const itcD = YintD[i], itcA = YintA[i], itcU = YintU[i];
    const pi = Ypi[i], piA = YpiA[i], piU = YpiU[i];
    if (Number.isFinite(x) && Number.isFinite(itcD)) ptsIntD.push([x, itcD]);
    if (Number.isFinite(x) && Number.isFinite(itcA)) ptsIntA.push([x, itcA]);
    if (Number.isFinite(x) && Number.isFinite(itcU)) ptsIntU.push([x, itcU]);

    if (Number.isFinite(x) && Number.isFinite(pi)) ptsPI.push([x, pi]);
    if (Number.isFinite(x) && Number.isFinite(piA)) ptsPIA.push([x, piA]);
    if (Number.isFinite(x) && Number.isFinite(piU)) ptsPIU.push([x, piU]);

    if (Number.isFinite(itcD) && Number.isFinite(pi)) ptsScatterRaw.push([itcD, pi]);
    if (Number.isFinite(itcA) && Number.isFinite(piA)) ptsFitScatterA.push([itcA, piA]);
    if (Number.isFinite(itcU) && Number.isFinite(piU)) ptsFitScatterU.push([itcU, piU]);
  }

  renderLineMulti(svgIntercept, [
    { pts: ptsIntD, color: '#3b82f6' },
    { pts: ptsIntA, color: '#eab308' },
    { pts: ptsIntU, color: '#22c55e' }
  ], {xLabel:'Days', yLabel:'Intercept (STB/day)', emptyEl: emptyIntercept});

  renderLineMulti(svgPI, [
    { pts: ptsPI, color: '#3b82f6' },
    { pts: ptsPIA, color: '#eab308' },
    { pts: ptsPIU, color: '#22c55e' }
  ], {xLabel:'Days', yLabel:'IPR (STB/(day.psi))', emptyEl: emptyPI});

  renderScatterMulti(svgPIvsInt, [
    { pts: ptsScatterRaw, color: '#3b82f6' },
    { pts: ptsFitScatterA, color: '#eab308' },
    { pts: ptsFitScatterU, color: '#22c55e' }
  ], {xLabel:'Intercept (STB/day)', yLabel:'IPR (STB/(day.psi))', emptyEl: emptyPIvsInt});

  const diags = buildDiagnostics({Days:X, InterceptDarcy:YintD, PI:Ypi, BP_psi:comp.__plot.BP_psi, BHP_psi:comp.__plot.BHP_psi, q_stbd:comp.__plot.q_stbd});
  if (!diags.length){
    diagBox.innerHTML = `<span class="ok">All checks passed.</span>`;
  } else {
    const items = diags.slice(0, 30).map(m=>`<li>${m}</li>`).join('');
    diagBox.innerHTML = `<div class="bad"><b>${diags.length}</b> issue(s) detected:</div><ul>${items}</ul>`;
  }
}

/** Safe render wrapper */
function safeRenderAll(){
  try { renderAllPlotsAndDiag(); }
  catch (err){
    const msg = (err && err.stack) ? err.stack : String(err);
    diagBox.innerHTML = `<div class="bad"><b>Runtime error:</b><pre style="white-space:pre-wrap">${msg}</pre></div>`;
    console.error(err);
  }
}

/** Units wiring */
function renderUnits(){
  const w=wells.find(x=>x.id===activeWellId); if (!w) return;
  u_time.value = w.units.time;
  u_bp.value = w.units.bp;
  u_bhp.value = w.units.bhp;
  u_oil.value = w.units.oil;
  u_gas.value = w.units.gas;
  u_wat.value = w.units.wat;
}
u_time.onchange = ()=>{ const w=wells.find(x=>x.id===activeWellId); if (w) { w.units.time = u_time.value; safeRenderAll(); } };
u_bp.onchange = ()=>{ const w=wells.find(x=>x.id===activeWellId); if (w) { w.units.bp = u_bp.value; safeRenderAll(); } };
u_bhp.onchange = ()=>{ const w=wells.find(x=>x.id===activeWellId); if (w) { w.units.bhp = u_bhp.value; safeRenderAll(); } };
u_oil.onchange = ()=>{ const w=wells.find(x=>x.id===activeWellId); if (w) { w.units.oil = u_oil.value; safeRenderAll(); } };
u_gas.onchange = ()=>{ const w=wells.find(x=>x.id===activeWellId); if (w) { w.units.gas = u_gas.value; safeRenderAll(); } };
u_wat.onchange = ()=>{ const w=wells.find(x=>x.id===activeWellId); if (w) { w.units.wat = u_wat.value; safeRenderAll(); } };

/** Export mode wiring */
exportModeSel.onchange = () => {
  exportMode = exportModeSel.value;
  legendExportMode.textContent = exportMode === 'anchored' ? 'Anchored' : 'Unanchored';
};

/** UI actions */
document.getElementById('addWellBtn').onclick = () => addWell();
downloadBtn.onclick = () => download(`ipr_decline_curves_${exportMode}.json`, buildJson());
deleteWellBtn.onclick = () => { const w=wells.find(x=>x.id===activeWellId); if (!w) return; deleteWellWithMaybeConfirm(w.id); };
deleteAllBtn.onclick = () => { if (confirm("Delete all wells and reset to P1?")) resetAllWells(); };
clearDataBtn.onclick = () => { const w=wells.find(x=>x.id===activeWellId); if (!w) return; if (!confirm(`Clear all rows for well "${w.name}"?`)) return; w.tableData = Array.from({length:30},()=>Array(WELL_COLS.length).fill('')); renderTable(); safeRenderAll(); };
duplicateBtn.onclick = () => { const n = Number(copyCountInput.value); duplicateActiveWell(Number.isFinite(n) ? n : 1); };

/** Global error surfacing */
window.onerror = function(message, source, lineno, colno, error){
  const detail = (error && error.stack) ? error.stack : `${message} at ${source}:${lineno}:${colno}`;
  diagBox.innerHTML = `<div class="bad"><b>Runtime error:</b><pre style="white-space:pre-wrap">${detail}</pre></div>`;
};

/** Boot */
addWell('P1');
legendExportMode.textContent = 'Anchored';
</script>
</body>
</html>
