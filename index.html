<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>IXFM Decline Curve Generator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0f172a; --card:#111827; --muted:#94a3b8; --text:#e5e7eb; --brand:#22c55e; --accent:#3b82f6; --danger:#ef4444; --border:#1f2937; --slb:#003366; }
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;background:var(--bg);color:var(--text)}
    header{padding:14px 16px;display:flex;gap:10px;flex-wrap:wrap;align-items:center;border-bottom:1px solid var(--border);position:sticky;top:0;background:linear-gradient(180deg,var(--slb) 0%,#012a52 100%);color:#fff;z-index:2}
    .brandwrap{display:flex;flex-direction:column;margin-right:8px}.title{font-size:18px;font-weight:700;line-height:1.1}.subtitle{font-size:12px;opacity:.9}
    .btn{padding:8px 12px;border:1px solid rgba(255,255,255,.2);border-radius:10px;background:rgba(255,255,255,.06);color:#fff;cursor:pointer;font-weight:600;font-size:12px}
    .btn:hover{background:rgba(255,255,255,.1)}.btn.brand{background:#16a34a;border-color:#0e7a34;color:#052e16}.btn.danger{background:var(--danger);border-color:#991b1b;color:#fff}.btn.dark{background:#0b1220;border-color:#2a364d;color:#e5e7eb}
    .hint{color:#e5e7eb;opacity:.85;font-size:11px}
    .tabs{display:flex;flex-wrap:wrap;gap:6px;row-gap:8px;padding:10px 16px;margin-top:12px;border-bottom:1px solid var(--border);background:#0e1527}
    .tab{display:flex;align-items:center;gap:6px;padding:6px 10px;border:1px solid var(--border);background:var(--card);border-radius:10px;cursor:pointer;white-space:nowrap;font-size:12px}
    .tab.active{outline:2px solid var(--accent)}.tab input{background:transparent;color:#e5e7eb;border:none;width:120px;font-weight:600;font-size:12px}.tab .x{font-weight:800;color:#94a3b8;cursor:pointer}

    /* page-level mode tabs */
    .mtabs{display:flex;gap:8px;padding:10px 16px;background:#0b1220;border-bottom:1px solid var(--border)}
    .mtab{padding:6px 10px;border:1px solid var(--border);border-radius:10px;background:#0f1528;cursor:pointer;font-size:12px;color:#cbd5e1;opacity:.9}
    .mtab.active{outline:2px solid var(--accent);opacity:1}

    /* Layout */
    .wrap{padding:16px;display:flex;justify-content:center}.container{width:100%;max-width:980px}.card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px}
    .controls{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:10px;flex-wrap:wrap;font-size:12px}.right{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}

    .units{display:grid;grid-template-columns:repeat(6,minmax(120px,1fr));gap:8px;margin:10px 0 6px}
    .units label{display:flex;flex-direction:column;gap:4px;font-size:11px;color:var(--muted)}
    select,input[type="number"]{background:#0b1220;color:#e5e7eb;border:1px solid var(--border);border-radius:8px;padding:6px 8px;font-size:12px}
    input[type="number"]{width:72px}

    table{width:100%;border-collapse:collapse;table-layout:fixed}
    thead th{position:sticky;top:0;background:#0b1220;z-index:1}
    th,td{border:1px solid #1f2937;padding:6px;text-align:left;vertical-align:top;font-size:12px;line-height:1.2}
    td[contenteditable="true"]{outline:none}td:focus{box-shadow:inset 0 0 0 2px var(--accent)}

    .plot-title{font-size:12px;color:var(--muted);margin-bottom:8px}
    .plot-wrap{width:100%;overflow:auto}.plot-empty{font-size:12px;color:var(--muted);padding:8px}
    .diag{font-size:12px;color:#eab308}.diag .ok{color:#22c55e}.diag .bad{color:#f87171}.diag ul{margin:6px 0 0 18px;padding:0}
    .legend{display:flex;gap:12px;align-items:center;margin-top:6px;font-size:11px;color:#cbd5e1;flex-wrap:wrap}.legend .item{display:flex;gap:6px;align-items:center}.chip{width:14px;height:3px;border-radius:2px;display:inline-block}

    /* discrete QC toggle button (top-right) */
    .spacer{flex:1}
    .iconbtn{display:inline-flex;align-items:center;justify-content:center;width:28px;height:28px;border-radius:8px;border:1px solid rgba(255,255,255,.2);background:rgba(0,0,0,.15);cursor:pointer}
    .iconbtn:hover{background:rgba(255,255,255,.12)}
    .iconbtn svg{width:16px;height:16px;opacity:.9}

    /* helper */
    .hidden{display:none !important}
  </style>
</head>
<body>
  <header>
    <div class="brandwrap">
      <div class="title">IXFM Decline Curve Generator</div>
      <div class="subtitle">Prototype Version</div>
    </div>

    <button class="btn dark" id="addWellBtn">+ Add Well</button>
    <button class="btn brand" id="downloadBtn">Download JSON (Anchored)</button>
    <button class="btn danger" id="deleteAllBtn">Delete All Wells</button>
    <span class="hint">Tip: paste from Excel; rows auto-expand.</span>

    <div class="spacer"></div>

    <!-- QC plots visibility toggle -->
    <button class="iconbtn" id="qcToggleBtn" title="Toggle QC plots">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M1 12s4-7 11-7 11 7 11 7-4 7-11 7S1 12 1 12z"></path>
        <circle cx="12" cy="12" r="3"></circle>
      </svg>
    </button>
  </header>

  <!-- page-level mode tabs -->
  <div class="mtabs" id="modeTabs">
    <div class="mtab active" data-mode="smoothing">Smoothing DC</div>
    <div class="mtab" data-mode="raw">Raw DC</div>
  </div>

  <!-- well tabs -->
  <div class="tabs" id="tabs"></div>

  <div class="wrap">
    <div class="container">
      <div class="card">
        <div class="controls">
          <div class="mono">Active: <span id="activeWellName"></span></div>
          <div class="right">
            <label class="hint">Copies</label>
            <input id="copyCount" type="number" min="1" step="1" value="1" />
            <button class="btn dark" id="duplicateBtn">Duplicate</button>
            <button class="btn dark" id="clearDataBtn">Clear Data</button>
            <button class="btn danger" id="deleteWellBtn">Delete Well</button>
          </div>
        </div>

        <div class="units">
          <label>Time Unit
            <select id="u_time">
              <option value="d">days</option>
              <option value="h">hours</option>
              <option value="mo30">months (30 d)</option>
              <option value="y365">years (365 d)</option>
            </select>
          </label>
          <label>Block P Unit
            <select id="u_bp">
              <option value="kpa">kPa</option>
              <option value="bar">bar</option>
              <option value="mpa">MPa</option>
              <option value="psi">psi</option>
            </select>
          </label>
          <label>BHP Unit
            <select id="u_bhp">
              <option value="kpa">kPa</option>
              <option value="bar">bar</option>
              <option value="mpa">MPa</option>
              <option value="psi">psi</option>
            </select>
          </label>
          <label>Oil Rate Unit
            <select id="u_oil">
              <option value="m3d">m³/day</option>
              <option value="stbd">STB/day</option>
              <option value="m3h">m³/hour</option>
            </select>
          </label>
          <label>Gas Rate Unit
            <select id="u_gas">
              <option value="m3d">m³/day</option>
              <option value="mscf">MSCF/day</option>
              <option value="mmscf">MMSCF/day</option>
            </select>
          </label>
          <label>Water Rate Unit
            <select id="u_wat">
              <option value="m3d">m³/day</option>
              <option value="stbd">STB/day</option>
              <option value="m3h">m³/hour</option>
            </select>
          </label>
        </div>

        <div style="overflow:auto;">
          <table>
            <thead>
              <tr>
                <th>Time</th>
                <th>Well Block Pressure - 9P</th>
                <th>Bottom-hole Pressure</th>
                <th>Oil Rate</th>
                <th>Gas Rate</th>
                <th>Water Rate</th>
              </tr>
            </thead>
            <tbody id="tableBody"></tbody>
          </table>
        </div>
      </div>

      <!-- legend card: now tied to QC toggle -->
      <div class="card qc-plot" style="margin-top:12px;">
        <div class="legend mono">
          <div class="item"><span class="chip" style="background:#3b82f6"></span>Raw</div>
          <div class="item"><span class="chip" style="background:#eab308"></span>Anchored Fit</div>
        </div>
      </div>

      <!-- QC plot cards -->
      <div class="card qc-plot" style="margin-top:12px;">
        <div class="plot-title mono">Intercept (q @ pwf=0) vs Cumulative Oil — STB/day</div>
        <div class="plot-wrap">
          <svg id="plotIntercept" width="100%" height="280" viewBox="0 0 900 280" preserveAspectRatio="none"></svg>
          <div id="emptyIntercept" class="plot-empty" style="display:none;">Enter at least two valid rows (Time, BP, BHP, Oil).</div>
        </div>
      </div>

      <div class="card qc-plot" style="margin-top:12px;">
        <div class="plot-title mono">IPR (Productivity Index) vs Cumulative Oil — STB/(day.psi)</div>
        <div class="plot-wrap">
          <svg id="plotPI" width="100%" height="280" viewBox="0 0 900 280" preserveAspectRatio="none"></svg>
          <div id="emptyPI" class="plot-empty" style="display:none;">Enter at least two valid rows (Time, BP, BHP, Oil).</div>
        </div>
      </div>

      <div class="card qc-plot" style="margin-top:12px;">
        <div class="plot-title mono">IPR vs Intercept — Scatter (Raw vs Anchored)</div>
        <div class="plot-wrap">
          <svg id="plotPIvsInt" width="100%" height="300" viewBox="0 0 900 300" preserveAspectRatio="none"></svg>
          <div id="emptyPIvsInt" class="plot-empty" style="display:none;">Enter at least two valid rows (Time, BP, BHP, Oil).</div>
        </div>
      </div>

      <!-- diagnostics card: now tied to QC toggle -->
      <div class="card qc-plot" style="margin-top:12px;">
        <div class="plot-title mono">Diagnostics — Sanity Checks (Darcy IPR)</div>
        <div class="diag" id="diagBox"><span class="ok">No issues yet.</span></div>
      </div>
    </div>
  </div>

<script>
/** Constants & state */
const WELL_COLS = ["Time","Well Block Pressure - 9P","Bottom-hole Pressure","Oil Rate","Gas Rate","Water Rate"];
const SERIES_META = {
  OIL_PRODUCTION_CUML: { description:"Oil production cumulative rate", displayUnit:"STB", measurementID:"Liquid_Production_Volume" },
  GAS_OIL_RATIO: { description:"Gas Oil Ratio", displayUnit:"MSCF/STB", measurementID:"Gas_To_Liquid_Ratio" },
  WATER_CUT: { description:"Water Cut", displayUnit:"STB/STB", measurementID:"Liquid_To_Liquid_Ratio" },
  INTERCEPT_OIL_PHASE_IPR_REF_DEPTH: { description:"Oil phase IPR intercept", displayUnit:"STB/day", measurementID:"Liquid_Flowrate" },
  SCALING_FACTOR_OIL_PHASE_IPR_REF_DEPTH: { description:"Oil phase IPR scaling factor", displayUnit:"STB/(day.psi)", measurementID:"Liquid_Productivity_Index" }
};
const M3_TO_STB = 6.28981077, STB_TO_M3 = 1/M3_TO_STB;
const M3_TO_MMSCF = 35.3146667 / 1e6;
const PSI_TO_KPA = 6.894757293168, BAR_TO_KPA = 100.0, MPA_TO_KPA = 1000.0;

let wells = []; let activeWellId = null;

/* page mode + QC toggle state */
let appMode = 'smoothing'; // 'smoothing' | 'raw'
let qcVisible = false; // default hidden on boot

/** DOM refs */
const modeTabsEl = document.getElementById('modeTabs');
const tabsEl = document.getElementById('tabs');
const bodyEl = document.getElementById('tableBody');
const addWellBtn = document.getElementById('addWellBtn');
const downloadBtn = document.getElementById('downloadBtn');
const deleteAllBtn = document.getElementById('deleteAllBtn');
const deleteWellBtn = document.getElementById('deleteWellBtn');
const clearDataBtn = document.getElementById('clearDataBtn');
const duplicateBtn = document.getElementById('duplicateBtn');
const copyCountInput = document.getElementById('copyCount');
const activeWellNameEl = document.getElementById('activeWellName');
const qcToggleBtn = document.getElementById('qcToggleBtn');

const u_time = document.getElementById('u_time');
const u_bp = document.getElementById('u_bp');
const u_bhp = document.getElementById('u_bhp');
const u_oil = document.getElementById('u_oil');
const u_gas = document.getElementById('u_gas');
const u_wat = document.getElementById('u_wat');
const svgIntercept = document.getElementById('plotIntercept');
const svgPI = document.getElementById('plotPI');
const svgPIvsInt = document.getElementById('plotPIvsInt');
const emptyIntercept = document.getElementById('emptyIntercept');
const emptyPI = document.getElementById('emptyPI');
const emptyPIvsInt = document.getElementById('emptyPIvsInt');
const diagBox = document.getElementById('diagBox');

/** Helpers */
const uuid = () => Math.random().toString(36).slice(2,9);
const toNumber = v => { if (typeof v === 'number') return v; if (v==null) return NaN; const s=String(v).trim().replace(/,/g,''); if(!s) return NaN; const n=Number(s); return Number.isFinite(n)?n:NaN; };
const isMostlyNonNumericRow = row => row.map(toNumber).filter(Number.isFinite).length <= 2;
function ensureRows(well, rowsNeeded){ const add = Math.max(0, rowsNeeded - well.tableData.length); for (let i=0;i<add;i++) well.tableData.push(Array(WELL_COLS.length).fill('')); return add; }
function isWellEmpty(well){ for (const row of well.tableData) for (const cell of row) if (String(cell ?? '').trim() !== '') return false; return true; }
function nextAvailableWellName(){ const used=new Set(); for(const w of wells){ const m=/^P(\d+)$/.exec(w.name.trim()); if(m) used.add(+m[1]); } let n=1; while(used.has(n)) n++; return `P${n}`; }

/* sanitize for JSON safety */
function sanitizeArray(arr){ return (arr||[]).map(v => Number.isFinite(v) ? v : 0); }

/** Units */
function factorTimeToDays(code){ switch(code){ case 'd': return 1; case 'h': return 1/24; case 'mo30': return 30; case 'y365': return 365; default: return 1; } }
function factorPressureToKPa(code){ switch(code){ case 'kpa': return 1; case 'bar': return BAR_TO_KPA; case 'mpa': return MPA_TO_KPA; case 'psi': return PSI_TO_KPA; default: return 1; } }
function factorOilWaterToM3d(code){ switch(code){ case 'm3d': return 1; case 'stbd': return STB_TO_M3; case 'm3h': return 24; default: return 1; } }
function factorGasToM3d(code){ switch(code){ case 'm3d': return 1; case 'mscf': return 28.316846592; case 'mmscf': return 28316.846592; default: return 1; } }
function applyFactorArray(arr, factor){ return arr.map(v => Number.isFinite(v) ? v*factor : NaN); }

/** Math & fitting (unchanged) */
const MAX_SEGMENTS = 6;
function aicFromSSE(sse, n, k){ return (n>0) ? (n * Math.log(Math.max(sse/n,1e-18)) + 2*k) : Infinity; }
function enforceNonIncreasing(arr){
  if(!arr.length) return arr.slice();
  const out=arr.slice();
  let seed = 0;
  for(let i=0;i<out.length;i++){ if(Number.isFinite(out[i])){ seed = Math.max(0,out[i]); break; } }
  if(!Number.isFinite(out[0])) out[0] = seed;
  for(let i=1;i<out.length;i++){
    if(!Number.isFinite(out[i])) out[i]=out[i-1];
    if(out[i]>out[i-1]) out[i]=out[i-1];
    if(out[i]<0) out[i]=0;
  }
  return out;
}
function validIndexMap(X,Y){
  const idx=[];
  for(let i=0;i<X.length;i++){ const xi=X[i], yi=Y[i]; if(Number.isFinite(xi)&&Number.isFinite(yi)&&yi>=0) idx.push(i); }
  return idx;
}
function validXY(X,Y){
  const x=[], y=[];
  for(let i=0;i<X.length;i++){
    const xi=X[i], yi=Y[i];
    if(Number.isFinite(xi) && Number.isFinite(yi) && yi>=0){ x.push(Math.max(0,xi)); y.push(yi); }
  }
  return {x,y};
}
function validXYW(X,Y,W){
  const x=[], y=[], w=[];
  for(let i=0;i<X.length;i++){
    const xi=X[i], yi=Y[i];
    let wi = (W && Number.isFinite(W[i])) ? Math.max(0, W[i]) : 1;
    if(Number.isFinite(xi) && Number.isFinite(yi) && yi>=0 && wi>0){ x.push(Math.max(0,xi)); y.push(yi); w.push(wi); }
  }
  return {x,y,w};
}
function linRegAnchoredConstrained(x, y, a0, x0){
  const n = x.length; if(n<1) return {b:0,sse:0};
  let num=0, den=0; for(let i=0;i<n;i++){ const dx=x[i]-x0; num += dx*(y[i]-a0); den += dx*dx; }
  let b = (den>0)? (num/den) : 0; if(!Number.isFinite(b) || b>0) b=0;
  let sse=0; for(let i=0;i<n;i++){ const e=(a0 + b*(x[i]-x0)) - y[i]; sse+=e*e; }
  return {b,sse};
}
function linRegAnchoredWeighted(x, y, w, a0, x0){
  const n=x.length; if(n<1) return {b:0,sse:0};
  let num=0, den=0;
  for(let i=0;i<n;i++){ const dx=x[i]-x0; const wi=w[i]; num += wi*dx*(y[i]-a0); den += wi*dx*dx; }
  let b = (den>0)? (num/den) : 0; if(!Number.isFinite(b) || b>0) b=0;
  let sse=0; for(let i=0;i<n;i++){ const e=(a0 + b*(x[i]-x0)) - y[i]; sse += w[i]*e*e; }
  return {b,sse};
}
function precomputeSSE(x,y){
  const n=x.length; const SSE=Array.from({length:n},()=>Array(n).fill(Infinity));
  for(let i=0;i<n;i++){
    let sx=0, sy=0, sxx=0, sxy=0, m=0;
    for(let j=i;j<n;j++){
      const xx=x[j], yy=y[j]; m++; sx+=xx; sy+=yy; sxx+=xx*xx; sxy+=xx*yy;
      const denom = m*sxx - sx*sx;
      let b = (Math.abs(denom)<1e-12)?0:(m*sxy - sx*sy)/denom; if(!Number.isFinite(b) || b>0) b=0;
      const a = (sy - b*sx)/m;
      let sse=0; for(let k=i;k<=j;k++){ const e=(a + b*x[k]) - y[k]; sse+=e*e; }
      SSE[i][j]=sse;
    }
  }
  return SSE;
}
function dpBreaks(x,y,Kmax){
  const n=x.length; const SSE=precomputeSSE(x,y);
  const maxK = Math.min(Kmax, Math.max(1, Math.floor(n/3)));
  const dp = Array.from({length:maxK+1},()=>Array(n).fill(Infinity));
  const prev = Array.from({length:maxK+1},()=>Array(n).fill(-1));
  for(let j=0;j<n;j++){ dp[1][j]=SSE[0][j]; prev[1][j]=-1; }
  for(let k=2;k<=maxK;k++){
    for(let j=0;j<n;j++){
      let best=Infinity, besti=-1;
      for(let i=k-2;i<j;i++){
        const cand = dp[k-1][i] + SSE[i+1][j];
        if(cand<best){ best=cand; besti=i; }
      }
      dp[k][j]=best; prev[k][j]=besti;
    }
  }
  const models=[];
  for(let k=1;k<=maxK;k++){
    let j=n-1; const ends=[];
    for(let seg=k; seg>=1; seg--){ ends.unshift(j); j = prev[seg][j]; }
    models.push({K:k, ends});
  }
  return models;
}
function buildAnchoredContinuous(x,y,ends,anchorY){
  const pred=new Array(x.length).fill(NaN);
  let start=0; let x0=0; let a0=anchorY;
  for(const end of ends){
    const segx=x.slice(start,end+1), segy=y.slice(start,end+1);
    const {b}=linRegAnchoredConstrained(segx,segy,a0,x0);
    for(let i=start;i<=end;i++) pred[i]=Math.max(0, a0 + b*(x[i]-x0));
    x0 = x[end]; a0 = pred[end]; start=end+1;
  }
  return pred;
}
function buildAnchoredContinuousWeighted(x,y,w,ends,anchorY){
  const pred=new Array(x.length).fill(NaN);
  let start=0; let x0=0; let a0=anchorY;
  for(const end of ends){
    const segx=x.slice(start,end+1), segy=y.slice(start,end+1), segw=w.slice(start,end+1);
    const {b}=linRegAnchoredWeighted(segx,segy,segw,a0,x0);
    for(let i=start;i<=end;i++) pred[i]=Math.max(0, a0 + b*(x[i]-x0));
    x0 = x[end]; a0 = pred[end]; start=end+1;
  }
  return pred;
}
function bestAnchoredPiecewise_Unweighted(X,Y,A0){
  const {x,y}=validXY(X,Y);
  const n=x.length; if(n<2){
    const out=new Array(X.length).fill(0); let j=0;
    for(let i=0;i<X.length;i++){ const xi=X[i], yi=Y[i]; if(Number.isFinite(xi)&&Number.isFinite(yi)&&yi>=0){ out[i]=yi; j++; } }
    return {pred:enforceNonIncreasing(out), ends:[X.length-1], validIdx: validIndexMap(X,Y)};
  }
  const cand = dpBreaks(x,y,MAX_SEGMENTS);
  const {b:blin,sse:sseLin}=linRegAnchoredConstrained(x,y,(A0||0),0);
  const predLin=x.map(t=>Math.max(0,(A0||0)+blin*t));
  let best = {pred:predLin, aic:aicFromSSE(sseLin,n,1), ends:[n-1]};
  for(const m of cand){
    const pred = buildAnchoredContinuous(x,y,m.ends,(A0||0));
    let sse=0; for(let i=0;i<n;i++){ const e=pred[i]-y[i]; sse+=e*e; }
    const aic = aicFromSSE(sse,n,(m.K+(m.K-1)));
    if(aic<best.aic) best = {pred,aic,ends:m.ends.slice()};
  }
  const validIdx = validIndexMap(X,Y);
  const back = new Array(X.length).fill(NaN); let j=0;
  for(let i=0;i<X.length;i++){ const xi=X[i], yi=Y[i]; if(Number.isFinite(xi)&&Number.isFinite(yi)&&yi>=0){ back[i]=best.pred[j++]; } }
  return {pred:enforceNonIncreasing(back), ends:best.ends, validIdx};
}
function bestAnchoredPiecewise_Weighted_withFixedEnds(X,Y,A0,W,fixedGlobalEnds){
  const validIdx = [];
  const x=[], y=[], w=[];
  for(let i=0;i<X.length;i++){
    const xi=X[i], yi=Y[i]; const wi=(W && Number.isFinite(W[i]))?Math.max(0,W[i]):1;
    if(Number.isFinite(xi)&&Number.isFinite(yi)&&yi>=0 && wi>0){ validIdx.push(i); x.push(Math.max(0,xi)); y.push(yi); w.push(wi); }
  }
  const n=x.length;
  if(n<2){
    const out=new Array(X.length).fill(0); let j=0;
    for(let i=0;i<X.length;i++){ const xi=X[i], yi=Y[i], wi=(W?W[i]:1); if(Number.isFinite(xi)&&Number.isFinite(yi)&&yi>=0&&(wi>0)){ out[i]=yi; j++; } }
    return {pred:enforceNonIncreasing(out)};
  }
  const piEnds = [];
  let last = -1;
  for (const gEnd of fixedGlobalEnds){
    let k = validIdx.findIndex(id => id >= gEnd);
    if (k === -1) k = validIdx.length - 1;
    if (k <= last) continue;
    piEnds.push(k);
    last = k;
  }
  if (piEnds[piEnds.length-1] !== n-1) piEnds[piEnds.length-1] = n-1;
  const pred = buildAnchoredContinuousWeighted(x,y,w,piEnds,(A0||0));
  const back=new Array(X.length).fill(NaN); let j=0;
  for(let i=0;i<X.length;i++){ const xi=X[i], yi=Y[i], wi=(W?W[i]:1); if(Number.isFinite(xi)&&Number.isFinite(yi)&&yi>=0 && wi>0){ back[i]=pred[j++]; } }
  return {pred:enforceNonIncreasing(back)};
}

/** Tabs & wells */
function defaultUnits(){ return { time:'d', bp:'kpa', bhp:'kpa', oil:'m3d', gas:'m3d', wat:'m3d' }; }
function createWell(name){ return { id: uuid(), name, units: defaultUnits(), tableData: Array.from({length:30}, () => Array(WELL_COLS.length).fill('')) }; }
function addWell(initialName){ const name=initialName ?? `P${wells.length+1}`; const w=createWell(name); wells.push(w); setActiveWell(w.id); renderTabs(); renderTable(); renderUnits(); safeRenderAll(); }
function deleteWell(id){ wells = wells.filter(w=>w.id!==id); if(!wells.length) addWell('P1'); setActiveWell(wells[0].id); renderTabs(); renderTable(); renderUnits(); safeRenderAll(); }
function deleteWellWithMaybeConfirm(id){ const w=wells.find(x=>x.id===id); if(!w) return; if(isWellEmpty(w)) deleteWell(id); else if(confirm(`Delete well "${w.name}"?`)) deleteWell(id); }
function resetAllWells(){ wells=[]; addWell('P1'); }
function setActiveWell(id){ activeWellId=id; activeWellNameEl.textContent=wells.find(w=>w.id===id)?.name ?? ''; }
function renameWell(id,newName){ const w=wells.find(x=>x.id===id); if(!w) return; w.name=newName.trim()||w.name; if(id===activeWellId) activeWellNameEl.textContent=w.name; }
function renderTabs(){ tabsEl.innerHTML=''; wells.forEach(w=>{ const tab=document.createElement('div'); tab.className='tab'+(w.id===activeWellId?' active':''); tab.onclick=()=>{ setActiveWell(w.id); renderTabs(); renderTable(); renderUnits(); safeRenderAll(); }; const input=document.createElement('input'); input.value=w.name; input.oninput=e=>renameWell(w.id,e.target.value); const close=document.createElement('span'); close.className='x'; close.textContent='×'; close.onclick=(ev)=>{ ev.stopPropagation(); deleteWellWithMaybeConfirm(w.id); }; tab.appendChild(input); tab.appendChild(close); tabsEl.appendChild(tab); }); }

/** Table */
function renderTable(){ const w=wells.find(x=>x.id===activeWellId); if(!w) return; bodyEl.innerHTML=''; w.tableData.forEach((row,r)=>{ const tr=document.createElement('tr'); for(let c=0;c<WELL_COLS.length;c++){ const td=document.createElement('td'); td.contentEditable='true'; td.spellcheck=false; td.dataset.row=r; td.dataset.col=c; td.textContent=row[c] ?? ''; td.addEventListener('input', onCellInput); td.addEventListener('paste', onCellPaste); tr.appendChild(td);} bodyEl.appendChild(tr); }); }
function onCellInput(e){ const td=e.currentTarget; const r=+td.dataset.row, c=+td.dataset.col; const w=wells.find(x=>x.id===activeWellId); w.tableData[r][c]=td.textContent; safeRenderAll(); }
function onCellPaste(e){ e.preventDefault(); const td=e.currentTarget; const startR=+td.dataset.row, startC=+td.dataset.col; const raw=(e.clipboardData||window.clipboardData).getData('text'); const lines=raw.replace(/\r/g,'').split('\n').filter(Boolean).map(l=>l.split('\t')); if(!lines.length) return; const payload=isMostlyNonNumericRow(lines[0])?lines.slice(1):lines; const w=wells.find(x=>x.id===activeWellId); const added=ensureRows(w, startR+payload.length); if(added>0) renderTable(); for(let i=0;i<payload.length;i++){ const cols=payload[i]; for(let j=0;j<cols.length && (startC+j)<WELL_COLS.length;j++){ const r=startR+i, c=startC+j; w.tableData[r][c]=cols[j]; const cell=bodyEl.querySelector(`td[data-row="${r}"][data-col="${c}"]`); if(cell) cell.textContent=cols[j]; } } safeRenderAll(); }

/** Core computation */
function computeWellSeriesPhysical(well){
  const data = well.tableData;
  const DAYS_raw = data.map(r=>toNumber(r[0]));
  const BP_raw   = data.map(r=>toNumber(r[1]));
  const BHP_raw  = data.map(r=>toNumber(r[2]));
  const OIL_raw  = data.map(r=>toNumber(r[3]));
  const GAS_raw  = data.map(r=>toNumber(r[4]));
  const WAT_raw  = data.map(r=>toNumber(r[5]));

  let L = DAYS_raw.length;
  for (; L>0; L--){
    const i=L-1;
    if ([DAYS_raw[i],BP_raw[i],BHP_raw[i],OIL_raw[i],GAS_raw[i],WAT_raw[i]].some(v=>Number.isFinite(v))) break;
  }
  if (L===0) return null;

  const fTime = factorTimeToDays(well.units.time);
  const fBP = factorPressureToKPa(well.units.bp);
  const fBHP = factorPressureToKPa(well.units.bhp);
  const fOil = factorOilWaterToM3d(well.units.oil);
  const fGas = factorGasToM3d(well.units.gas);
  const fWat = factorOilWaterToM3d(well.units.wat);

  const Days = applyFactorArray(DAYS_raw.slice(0,L), fTime);
  const BP_kPa = applyFactorArray(BP_raw.slice(0,L), fBP);
  const BHP_kPa = applyFactorArray(BHP_raw.slice(0,L), fBHP);
  const OIL_m3d = applyFactorArray(OIL_raw.slice(0,L), fOil);
  const GAS_m3d = applyFactorArray(GAS_raw.slice(0,L), fGas);
  const WAT_m3d = applyFactorArray(WAT_raw.slice(0,L), fWat);

  const oil_stb = OIL_m3d.map(v=>Number.isFinite(v)? Math.max(0, v*M3_TO_STB) : NaN);
  const wat_stb = WAT_m3d.map(v=>Number.isFinite(v)? Math.max(0, v*M3_TO_STB) : NaN);
  const gas_mmscf = GAS_m3d.map(v=>Number.isFinite(v)? Math.max(0, v*M3_TO_MMSCF) : NaN);
  const BP_psi = BP_kPa.map(v=>Number.isFinite(v)? v/PSI_TO_KPA : NaN);
  const BHP_psi = BHP_kPa.map(v=>Number.isFinite(v)? v/PSI_TO_KPA : NaN);

  const GOR = oil_stb.map((o,i)=> (Number.isFinite(o) && o>0) ? gas_mmscf[i]/o : NaN);
  const WATER_FRAC = oil_stb.map((o,i)=>{ const w = wat_stb[i]; const denom = (Number.isFinite(o)?o:0) + (Number.isFinite(w)?w:0); return denom > 0 ? (w/denom) : NaN; });

  const dDays = Days.map(v=>Number.isFinite(v)?v:0);
  for (let i=dDays.length-1;i>=1;i--) dDays[i] = (Number.isFinite(Days[i])?Days[i]:0) - (Number.isFinite(Days[i-1])?Days[i-1]:0);
  const oilVolPerDate = oil_stb.map((q,i)=>(Number.isFinite(q)?q:0) * (Number.isFinite(dDays[i])?dDays[i]:0));
  const CumOil = (function(){ const out=[]; let s=0; for(const v of oilVolPerDate){ s+=v; out.push(s);} return out; })();

  const dP = BP_psi.map((bp,i)=> (Number.isFinite(bp) && Number.isFinite(BHP_psi[i])) ? Math.max(0, bp - BHP_psi[i]) : NaN);

  let PI = oil_stb.map((q,i)=> { const dp=dP[i]; return (Number.isFinite(q) && Number.isFinite(dp) && dp>0) ? Math.max(0,q/dp) : NaN; });
  if (PI.length>=2 && !Number.isFinite(PI[0]) && Number.isFinite(PI[1])) PI[0]=PI[1];

  let INTERCEPT_DARCY = PI.map((pi,i)=> (Number.isFinite(pi) && Number.isFinite(BP_psi[i])) ? Math.max(0, pi*BP_psi[i]) : NaN);
  if (INTERCEPT_DARCY.length>=2 && !Number.isFinite(INTERCEPT_DARCY[0]) && Number.isFinite(INTERCEPT_DARCY[1])) INTERCEPT_DARCY[0]=INTERCEPT_DARCY[1];

  const intVals = INTERCEPT_DARCY.filter(v=>Number.isFinite(v) && v>=0);
  const piVals  = PI.filter(v=>Number.isFinite(v) && v>=0);
  const IntAnchor = intVals.length ? Math.max(...intVals) : 0;
  const PIAnchor  = piVals.length ? Math.max(...piVals) : 0;

  const Xcum = CumOil.slice();

  // 1) Intercept fit
  const interceptModel = bestAnchoredPiecewise_Unweighted(Xcum, INTERCEPT_DARCY, IntAnchor);
  const InterceptA = interceptModel.pred;
  const endsIntFiltered = interceptModel.ends;
  const validIntIdx = interceptModel.validIdx;
  const endsIntGlobal = endsIntFiltered.map(fi => validIntIdx[fi]);

  // 2) PI weights from Δp
  const dpValid = dP.filter(Number.isFinite).filter(v=>v>0);
  const dpMed = dpValid.length ? dpValid.sort((a,b)=>a-b)[Math.floor(dpValid.length/2)] : 1;
  const wPI = dP.map(v=>{
    if(!Number.isFinite(v) || v<=0) return 0.05;
    const r = v / (dpMed || 1);
    return Math.min(4, Math.max(0.25, r));
  });

  // 3) PI fit, sharing breakpoints
  const piForced = bestAnchoredPiecewise_Weighted_withFixedEnds(Xcum, PI, PIAnchor, wPI, endsIntGlobal);
  const PIA = piForced.pred;

  const sanitize = a => a.map(v=>Number.isFinite(v)?v:0);

  return {
    name: well.name.replace(/\./g,''),
    length: Xcum.length,
    OIL_PRODUCTION_CUML: sanitize(CumOil),
    GAS_OIL_RATIO: sanitize(GOR),
    WATER_CUT: sanitize(WATER_FRAC),
    INTERCEPT_A: sanitize(InterceptA),
    PI_A: sanitize(PIA),
    __plot: {
      Days,
      CumOil: Xcum.slice(),
      InterceptDarcy: INTERCEPT_DARCY.slice(),
      InterceptA: InterceptA.slice(),
      PI: PI.slice(),
      PIA: PIA.slice(),
      BP_psi: BP_psi.slice(),
      BHP_psi: BHP_psi.slice(),
      q_stbd: oil_stb.slice()
    }
  };
}

/** Export JSON */
function enforceLastZero(arr){ if(!arr||!arr.length) return arr; const out=arr.slice(); out[out.length-1]=0; return out; }

/* unified builder that respects appMode */
function buildJson(mode){
  const isAnchored = (mode === 'smoothing');
  const payload = { name:"IPR Decline Curves", series:[], step:{}, unitSystem:"ECLIPSE_FIELD", version:"v1", exportMode: isAnchored ? "anchored" : "raw" };

  for (const w of wells){
    const c = computeWellSeriesPhysical(w);
    if (!c) continue;

    payload.step[c.name] = Array.from({length:c.length}, (_,i)=>i);

    const baseOrder = [
      ["OIL_PRODUCTION_CUML","Oil production cumulative", c.OIL_PRODUCTION_CUML, "STB", "Liquid_Production_Volume"],
      ["GAS_OIL_RATIO","Gas oil ratio", c.GAS_OIL_RATIO, "MSCF/STB", "Gas_To_Liquid_Ratio"],
      ["WATER_CUT","Water cut", c.WATER_CUT, "STB/STB", "Liquid_To_Liquid_Ratio"]
    ];
    for (const [key, desc, arr, unit, mid] of baseOrder){
      payload.series.push({ description: desc, displayUnit: unit, entityName: c.name, entityType: "WELL", measurementID: mid, name: key, values: arr.slice() });
    }

    if (isAnchored){
      const INT_pp = enforceLastZero(c.INTERCEPT_A);
      const PI_pp  = enforceLastZero(c.PI_A);
      payload.series.push({
        description: SERIES_META.INTERCEPT_OIL_PHASE_IPR_REF_DEPTH.description,
        displayUnit: SERIES_META.INTERCEPT_OIL_PHASE_IPR_REF_DEPTH.displayUnit,
        entityName: c.name, entityType:"WELL",
        measurementID: SERIES_META.INTERCEPT_OIL_PHASE_IPR_REF_DEPTH.measurementID,
        name: "INTERCEPT_OIL_PHASE_IPR_REF_DEPTH",
        values: INT_pp.slice()
      });
      payload.series.push({
        description: SERIES_META.SCALING_FACTOR_OIL_PHASE_IPR_REF_DEPTH.description,
        displayUnit: SERIES_META.SCALING_FACTOR_OIL_PHASE_IPR_REF_DEPTH.displayUnit,
        entityName: c.name, entityType:"WELL",
        measurementID: SERIES_META.SCALING_FACTOR_OIL_PHASE_IPR_REF_DEPTH.measurementID,
        name: "SCALING_FACTOR_OIL_PHASE_IPR_REF_DEPTH",
        values: PI_pp.slice()
      });
    } else {
      const INT_raw = sanitizeArray(c.__plot?.InterceptDarcy || []);
      const PI_raw  = sanitizeArray(c.__plot?.PI || []);
      payload.series.push({
        description: SERIES_META.INTERCEPT_OIL_PHASE_IPR_REF_DEPTH.description,
        displayUnit: SERIES_META.INTERCEPT_OIL_PHASE_IPR_REF_DEPTH.displayUnit,
        entityName: c.name, entityType:"WELL",
        measurementID: SERIES_META.INTERCEPT_OIL_PHASE_IPR_REF_DEPTH.measurementID,
        name: "INTERCEPT_OIL_PHASE_IPR_REF_DEPTH",
        values: INT_raw.slice()
      });
      payload.series.push({
        description: SERIES_META.SCALING_FACTOR_OIL_PHASE_IPR_REF_DEPTH.description,
        displayUnit: SERIES_META.SCALING_FACTOR_OIL_PHASE_IPR_REF_DEPTH.displayUnit,
        entityName: c.name, entityType:"WELL",
        measurementID: SERIES_META.SCALING_FACTOR_OIL_PHASE_IPR_REF_DEPTH.measurementID,
        name: "SCALING_FACTOR_OIL_PHASE_IPR_REF_DEPTH",
        values: PI_raw.slice()
      });
    }
  }
  return payload;
}

/** Plotting (unchanged) */
function clearSVG(svg){ while (svg.firstChild) svg.removeChild(svg.firstChild); }
function makeSVG(tag){ return document.createElementNS('http://www.w3.org/2000/svg', tag); }

function renderLineMulti(svg, seriesList, {xLabel, yLabel, emptyEl}){
  clearSVG(svg);
  const allPts = seriesList.flatMap(s=>s.pts);
  if (!allPts.length || allPts.length < 2) { if (emptyEl) emptyEl.style.display='block'; return; }
  if (emptyEl) emptyEl.style.display='none';

  const wBox = svg.viewBox.baseVal.width || 900, hBox = svg.viewBox.baseVal.height || 280;
  const margin = {left:60, right:16, top:16, bottom:36};
  const W = wBox - margin.left - margin.right;
  const H = hBox - margin.top - margin.bottom;

  const xMin = 0, xMax = Math.max(...allPts.map(p=>p[0])) || 1;
  const yMin = 0, yMaxRaw = Math.max(...allPts.map(p=>p[1])) || 1;
  const yMax = (yMaxRaw<=0?1:yMaxRaw*1.1);

  const xMap = x => margin.left + (xMax===xMin?0:((x-xMin)/(xMax-xMin)))*W;
  const yMap = y => margin.top + H - (yMax===yMin?0:((y-yMin)/(yMax-yMin)))*H;

  const axes = makeSVG('g');
  const xAxis = makeSVG('line'); xAxis.setAttribute('x1', margin.left); xAxis.setAttribute('y1', margin.top+H); xAxis.setAttribute('x2', margin.left+W); xAxis.setAttribute('y2', margin.top+H); xAxis.setAttribute('stroke', '#2f3b52'); axes.appendChild(xAxis);
  const yAxis = makeSVG('line'); yAxis.setAttribute('x1', margin.left); yAxis.setAttribute('y1', margin.top); yAxis.setAttribute('x2', margin.left); yAxis.setAttribute('y2', margin.top+H); yAxis.setAttribute('stroke', '#2f3b52'); axes.appendChild(yAxis);

  const xticks=5, yticks=5;
  for (let i=0;i<=xticks;i++){
    const v = xMin + (i/xticks)*(xMax-xMin);
    const x = xMap(v);
    const t = makeSVG('line'); t.setAttribute('x1',x); t.setAttribute('y1',margin.top+H); t.setAttribute('x2',x); t.setAttribute('y2',margin.top+H+6); t.setAttribute('stroke','#2f3b52'); axes.appendChild(t);
    const lbl = makeSVG('text'); lbl.setAttribute('x',x); lbl.setAttribute('y',margin.top+H+20); lbl.setAttribute('text-anchor','middle'); lbl.setAttribute('font-size','11'); lbl.setAttribute('fill','#94a3b8'); lbl.textContent = (Math.round(v*100)/100).toString(); axes.appendChild(lbl);
  }
  for (let i=0;i<=yticks;i++){
    const v = yMin + (i/yticks)*(yMax-yMin);
    const y = yMap(v);
    const t = makeSVG('line'); t.setAttribute('x1',margin.left-6); t.setAttribute('y1',y); t.setAttribute('x2',margin.left); t.setAttribute('y2',y); t.setAttribute('stroke','#2f3b52'); axes.appendChild(t);
    const g = makeSVG('line'); g.setAttribute('x1',margin.left); g.setAttribute('y1',y); g.setAttribute('x2',margin.left+W); g.setAttribute('y2',y); g.setAttribute('stroke','#1f2937'); axes.appendChild(g);
    const lbl = makeSVG('text'); lbl.setAttribute('x',margin.left-8); lbl.setAttribute('y',y+4); lbl.setAttribute('text-anchor','end'); lbl.setAttribute('font-size','11'); lbl.setAttribute('fill','#94a3b8'); lbl.textContent = Math.round(v).toString(); axes.appendChild(lbl);
  }

  const xlab = makeSVG('text'); xlab.setAttribute('x', margin.left+W/2); xlab.setAttribute('y', margin.top+H+32); xlab.setAttribute('text-anchor','middle'); xlab.setAttribute('font-size','12'); xlab.setAttribute('fill','#cbd5e1'); xlab.textContent = xLabel; axes.appendChild(xlab);
  const ylab = makeSVG('text'); ylab.setAttribute('x', 12); ylab.setAttribute('y', margin.top+H/2); ylab.setAttribute('transform', `rotate(-90 12 ${margin.top+H/2})`); ylab.setAttribute('text-anchor','middle'); ylab.setAttribute('font-size','12'); ylab.setAttribute('fill','#cbd5e1'); ylab.textContent = yLabel; axes.appendChild(ylab);

  svg.appendChild(axes);

  for (const s of seriesList){
    if (!s.pts.length) continue;
    const d = s.pts.map((p,i)=>`${i?'L':'M'} ${xMap(p[0])} ${yMap(p[1])}`).join(' ');
    const path = makeSVG('path');
    path.setAttribute('d', d); path.setAttribute('fill','none');
    path.setAttribute('stroke', s.color || '#3b82f6'); path.setAttribute('stroke-width','2');
    if (s.dash) path.setAttribute('stroke-dasharray', s.dash);
    svg.appendChild(path);
  }
}

function renderScatterMulti(svg, seriesList, {xLabel, yLabel, emptyEl}){
  clearSVG(svg);
  const allPts = seriesList.flatMap(s=>s.pts);
  if (!allPts.length || allPts.length < 2) { if (emptyEl) emptyEl.style.display='block'; return; }
  if (emptyEl) emptyEl.style.display='none';

  const wBox = svg.viewBox.baseVal.width || 900, hBox = svg.viewBox.baseVal.height || 300;
  const margin = {left:70, right:16, top:16, bottom:42};
  const W = wBox - margin.left - margin.right;
  const H = hBox - margin.top - margin.bottom;

  const xMin = 0, xMax = Math.max(...allPts.map(p=>p[0])) || 1;
  const yMin = 0, yMax = Math.max(...allPts.map(p=>p[1])) || 1;
  const xMap = x => margin.left + (xMax===xMin?0:((x-xMin)/(xMax-xMin)))*W;
  const yMap = y => margin.top + H - (yMax===yMin?0:((y-yMin)/(yMax-yMin)))*H;

  const axes = makeSVG('g');
  const xAxis = makeSVG('line'); xAxis.setAttribute('x1',margin.left); xAxis.setAttribute('y1',margin.top+H); xAxis.setAttribute('x2',margin.left+W); xAxis.setAttribute('y2',margin.top+H); xAxis.setAttribute('stroke','#2f3b52'); axes.appendChild(xAxis);
  const yAxis = makeSVG('line'); yAxis.setAttribute('x1',margin.left); yAxis.setAttribute('y1',margin.top); yAxis.setAttribute('x2',margin.left); yAxis.setAttribute('y2',margin.top+H); yAxis.setAttribute('stroke','#2f3b52'); axes.appendChild(yAxis);

  const xticks=5, yticks=5;
  for (let i=0;i<=xticks;i++){
    const v = xMin + (i/xticks)*(xMax-xMin);
    const x = xMap(v);
    const t = makeSVG('line'); t.setAttribute('x1',x); t.setAttribute('y1',margin.top+H); t.setAttribute('x2',x); t.setAttribute('y2',margin.top+H+6); t.setAttribute('stroke','#2f3b52'); axes.appendChild(t);
    const lbl = makeSVG('text'); lbl.setAttribute('x',x); lbl.setAttribute('y',margin.top+H+24); lbl.setAttribute('text-anchor','middle'); lbl.setAttribute('font-size','11'); lbl.setAttribute('fill','#94a3b8'); lbl.textContent = Math.round(v).toString(); axes.appendChild(lbl);
  }
  for (let i=0;i<=yticks;i++){
    const v = yMin + (i/yticks)*(yMax-yMin);
    const y = yMap(v);
    const t = makeSVG('line'); t.setAttribute('x1',margin.left-6); t.setAttribute('y1',y); t.setAttribute('x2',margin.left); t.setAttribute('y2',y); t.setAttribute('stroke','#2f3b52'); axes.appendChild(t);
    const g = makeSVG('line'); g.setAttribute('x1',margin.left); g.setAttribute('y1',y); g.setAttribute('x2',margin.left+W); g.setAttribute('y2',y); g.setAttribute('stroke','#1f2937'); axes.appendChild(g);
    const lbl = makeSVG('text'); lbl.setAttribute('x',margin.left-8); lbl.setAttribute('y',y+4); lbl.setAttribute('text-anchor','end'); lbl.setAttribute('font-size','11'); lbl.setAttribute('fill','#94a3b8'); lbl.textContent = (Math.round(v*1000)/1000).toString(); axes.appendChild(lbl);
  }

  const xlab = makeSVG('text'); xlab.setAttribute('x', margin.left+W/2); xlab.setAttribute('y', margin.top+H+36); xlab.setAttribute('text-anchor','middle'); xlab.setAttribute('font-size','12'); xlab.setAttribute('fill','#cbd5e1'); xlab.textContent = xLabel; axes.appendChild(xlab);
  const ylab = makeSVG('text'); ylab.setAttribute('x', 14); ylab.setAttribute('y', margin.top+H/2); ylab.setAttribute('transform', `rotate(-90 14 ${margin.top+H/2})`); ylab.setAttribute('text-anchor','middle'); ylab.setAttribute('font-size','12'); ylab.setAttribute('fill','#cbd5e1'); ylab.textContent = yLabel; axes.appendChild(ylab);

  svg.appendChild(axes);

  for (const s of seriesList){
    for (const [xv,yv] of s.pts){
      if (!Number.isFinite(xv) || !Number.isFinite(yv)) continue;
      const c = makeSVG('circle');
      c.setAttribute('cx', xMap(xv)); c.setAttribute('cy', yMap(yv)); c.setAttribute('r', 3.2); c.setAttribute('fill', s.color || '#3b82f6');
      svg.appendChild(c);
    }
  }
}

/** Diagnostics (unchanged) */
function buildDiagnostics(plot){
  const msgs = [];
  const tolRel = 0.05;
  const {Days, InterceptDarcy, PI, BP_psi, BHP_psi, q_stbd} = plot;
  for (let i=0;i<Days.length;i++){
    const day = Days[i];
    const bp = BP_psi[i], bhp = BHP_psi[i];
    const q = q_stbd[i], pi = PI[i], itc = InterceptDarcy[i];
    if (![bp,bhp,q].every(Number.isFinite)) continue;
    const dp = Math.max(0, bp - bhp);
    if (bp < bhp) msgs.push(`t=${day}: BP < BHP → Δp<0 (check pressures).`);
    if (Number.isFinite(pi) && Number.isFinite(bp) && Number.isFinite(itc)){
      const expect = pi*bp, denom = Math.max(1, Math.abs(itc));
      const rel = Math.abs(itc - expect) / denom;
      if (rel > tolRel) msgs.push(`t=${day}: Intercept mismatch (>5%). I=${itc.toFixed(2)}, PI*BP=${expect.toFixed(2)}.`);
    }
    if (Number.isFinite(q) && Number.isFinite(itc) && q > itc*(1+tolRel))
      msgs.push(`t=${day}: q (${q.toFixed(2)}) > Intercept (${itc.toFixed(2)}).`);
    if (dp < 1e-6 && q > 0) msgs.push(`t=${day}: Δp≈0 but q>0 (check BHP/BP).`);
    if ((!Number.isFinite(pi) || pi===0) && q>0 && dp>0)
      msgs.push(`t=${day}: PI≈0 but q>0 and Δp>0 (check units).`);
  }
  return msgs;
}

/** Render */
function renderAllPlotsAndDiag(){
  const w = wells.find(x=>x.id===activeWellId);
  clearSVG(svgIntercept); clearSVG(svgPI); clearSVG(svgPIvsInt);
  if (!w) return;

  const comp = computeWellSeriesPhysical(w);
  if (!comp || !comp.__plot) {
    emptyIntercept.style.display='block'; emptyPI.style.display='block'; emptyPIvsInt.style.display='block';
    diagBox.innerHTML = `<span class="ok">No issues yet.</span>`; return;
  }

  const X = comp.__plot.CumOil || [];
  const YintD = comp.__plot.InterceptDarcy || [];
  const YintA = comp.__plot.InterceptA || [];
  const Ypi = comp.__plot.PI || [];
  const YpiA = comp.__plot.PIA || [];

  const ptsIntD = [], ptsIntA = [];
  const ptsPI = [], ptsPIA = [];
  const ptsScatterRaw = [], ptsFitScatterA = [];

  for (let i=0;i<X.length; i++){
    const x = X[i];
    const itcD = YintD[i], itcA = YintA[i];
    const pi = Ypi[i], piA = YpiA[i];
    if (Number.isFinite(x) && Number.isFinite(itcD)) ptsIntD.push([x, itcD]);
    if (Number.isFinite(x) && Number.isFinite(itcA)) ptsIntA.push([x, itcA]);

    if (Number.isFinite(x) && Number.isFinite(pi)) ptsPI.push([x, pi]);
    if (Number.isFinite(x) && Number.isFinite(piA)) ptsPIA.push([x, piA]);

    if (Number.isFinite(itcD) && Number.isFinite(pi)) ptsScatterRaw.push([itcD, pi]);
    if (Number.isFinite(itcA) && Number.isFinite(piA)) ptsFitScatterA.push([itcA, piA]);
  }

  renderLineMulti(svgIntercept, [
    { pts: ptsIntD, color: '#3b82f6' },
    { pts: ptsIntA, color: '#eab308' }
  ], {xLabel:'Cumulative Oil (STB)', yLabel:'Intercept (STB/day)', emptyEl: emptyIntercept});

  renderLineMulti(svgPI, [
    { pts: ptsPI, color: '#3b82f6' },
    { pts: ptsPIA, color: '#eab308' }
  ], {xLabel:'Cumulative Oil (STB)', yLabel:'IPR (STB/(day.psi))', emptyEl: emptyPI});

  renderScatterMulti(svgPIvsInt, [
    { pts: ptsScatterRaw, color: '#3b82f6' },
    { pts: ptsFitScatterA, color: '#eab308' }
  ], {xLabel:'Intercept (STB/day)', yLabel:'IPR (STB/(day.psi))', emptyEl: emptyPIvsInt});

  const diags = buildDiagnostics({Days:comp.__plot.Days, InterceptDarcy:YintD, PI:Ypi, BP_psi:comp.__plot.BP_psi, BHP_psi:comp.__plot.BHP_psi, q_stbd:comp.__plot.q_stbd});
  if (!diags.length){
    diagBox.innerHTML = `<span class="ok">All checks passed.</span>`;
  } else {
    const items = diags.slice(0, 30).map(m=>`<li>${m}</li>`).join('');
    diagBox.innerHTML = `<div class="bad"><b>${diags.length}</b> issue(s) detected:</div><ul>${items}</ul>`;
  }
}

/** Units wiring */
function renderUnits(){ const w=wells.find(x=>x.id===activeWellId); if(!w) return;
  u_time.value=w.units.time; u_bp.value=w.units.bp; u_bhp.value=w.units.bhp; u_oil.value=w.units.oil; u_gas.value=w.units.gas; u_wat.value=w.units.wat; }
u_time.onchange=()=>{ const w=wells.find(x=>x.id===activeWellId); if(w){ w.units.time=u_time.value; safeRenderAll(); } };
u_bp.onchange  =()=>{ const w=wells.find(x=>x.id===activeWellId); if(w){ w.units.bp=u_bp.value; safeRenderAll(); } };
u_bhp.onchange =()=>{ const w=wells.find(x=>x.id===activeWellId); if(w){ w.units.bhp=u_bhp.value; safeRenderAll(); } };
u_oil.onchange =()=>{ const w=wells.find(x=>x.id===activeWellId); if(w){ w.units.oil=u_oil.value; safeRenderAll(); } };
u_gas.onchange =()=>{ const w=wells.find(x=>x.id===activeWellId); if(w){ w.units.gas=u_gas.value; safeRenderAll(); } };
u_wat.onchange =()=>{ const w=wells.find(x=>x.id===activeWellId); if(w){ w.units.wat=u_wat.value; safeRenderAll(); } };

/** Download helper */
function downloadFile(filename, obj){
  try{
    const blob=new Blob([JSON.stringify(obj,null,2)],{type:"application/json"});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download=filename; document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  }catch(err){
    alert("Download failed: "+err);
  }
}

/** Mode UI wiring */
function updateModeUI(){
  Array.from(modeTabsEl.querySelectorAll('.mtab')).forEach(el=>{
    el.classList.toggle('active', el.dataset.mode === appMode);
  });
  downloadBtn.textContent = appMode === 'smoothing' ? 'Download JSON (Anchored)' : 'Download JSON (Raw)';
}
modeTabsEl.addEventListener('click', (e)=>{
  const t = e.target.closest('.mtab');
  if(!t) return;
  const mode = t.dataset.mode;
  if (mode && (mode === 'smoothing' || mode === 'raw')){
    appMode = mode;
    updateModeUI();
  }
});

/** QC plots toggle (display only) */
function applyQcVisibility(){
  // why: single control hides plots, legend, and diagnostics together
  document.querySelectorAll('.qc-plot').forEach(el => el.classList.toggle('hidden', !qcVisible));
  qcToggleBtn.style.opacity = qcVisible ? '1' : '0.6';
}
qcToggleBtn.onclick = () => { qcVisible = !qcVisible; applyQcVisibility(); };

/** UI actions */
addWellBtn.onclick = () => addWell();
downloadBtn.onclick = () => {
  const mode = appMode;
  const data = buildJson(mode);
  const fname = mode === 'smoothing' ? 'ipr_decline_curves_anchored.json' : 'ipr_decline_curves_raw.json';
  downloadFile(fname, data);
};
deleteWellBtn.onclick = () => { const w=wells.find(x=>x.id===activeWellId); if (!w) return; deleteWellWithMaybeConfirm(w.id); };
deleteAllBtn.onclick = () => { if (confirm("Delete all wells and reset to P1?")) resetAllWells(); };
clearDataBtn.onclick = () => { const w=wells.find(x=>x.id===activeWellId); if (!w) return; if (!confirm(`Clear all rows for well "${w.name}"?`)) return; w.tableData = Array.from({length:30},()=>Array(WELL_COLS.length).fill('')); renderTable(); safeRenderAll(); };
duplicateBtn.onclick = () => { 
  const n = Number(copyCountInput.value); 
  const count = Math.max(1, Math.floor(Number.isFinite(n)?n:1));
  const src = wells.find(x=>x.id===activeWellId);
  if(!src) return;
  for(let i=0;i<count;i++){
    const name=nextAvailableWellName(); const id=uuid();
    const tableCopy=src.tableData.map(row=>row.slice()); const unitsCopy={...src.units};
    wells.push({id,name,tableData:tableCopy,units:unitsCopy});
  }
  renderTabs(); safeRenderAll();
};

/** Safe render + global error surfacing */
function safeRenderAll(){
  try { renderAllPlotsAndDiag(); }
  catch (err){
    const msg = (err && err.stack) ? err.stack : String(err);
    diagBox.innerHTML = `<div class="bad"><b>Runtime error:</b><pre style="white-space:pre-wrap">${msg}</pre></div>`;
    console.error(err);
  }
}
window.onerror = function(message, source, lineno, colno, error){
  const detail = (error && error.stack) ? error.stack : `${message} at ${source}:${lineno}:${colno}`;
  diagBox.innerHTML = `<div class="bad"><b>Runtime error:</b><pre style="white-space:pre-wrap">${detail}</pre></div>`;
};

/** Boot */
updateModeUI();
addWell('P1');
applyQcVisibility(); // ensure hidden on page boot
</script>
</body>
</html>
