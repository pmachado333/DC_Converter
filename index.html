<!-- /mnt/data/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>IXFM Decline Curve Generator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0f172a; --card:#111827; --muted:#94a3b8; --text:#e5e7eb; --brand:#22c55e; --accent:#3b82f6; --danger:#ef4444; --border:#1f2937; --slb:#003366; --amber:#eab308; }
    * { box-sizing:border-box }
    body { margin:0; font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial; background:var(--bg); color:var(--text) }
    header { padding:14px 16px; display:flex; gap:10px; flex-wrap:wrap; align-items:center; border-bottom:1px solid var(--border); position:sticky; top:0; background: linear-gradient(180deg, var(--slb) 0%, #012a52 100%); color:#fff; z-index:2; }
    .brandwrap { display:flex; flex-direction:column; margin-right:8px }
    .title { font-size:18px; font-weight:700; line-height:1.1 }
    .subtitle { font-size:12px; opacity:.9 }
    .btn { padding:8px 12px; border:1px solid rgba(255,255,255,.2); border-radius:10px; background:rgba(255,255,255,.06); color:#fff; cursor:pointer; font-weight:600; font-size:12px }
    .btn:hover { background:rgba(255,255,255,.1) }
    .btn.brand { background:#16a34a; border-color:#0e7a34; color:#052e16 }
    .btn.danger { background:var(--danger); border-color:#991b1b; color:#fff }
    .btn.dark { background:#0b1220; border-color:#2a364d; color:#e5e7eb }
    .hint { color:#e5e7eb; opacity:.85; font-size:11px }
    .tabs { display:flex; flex-wrap:wrap; gap:6px; row-gap:8px; padding:10px 16px; margin-top:28px; border-bottom:1px solid var(--border); background:#0e1527; overflow:visible; }
    .tab { display:flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid var(--border); background:var(--card); border-radius:10px; cursor:pointer; white-space:nowrap; font-size:12px }
    .tab.active { outline:2px solid var(--accent) }
    .tab input { background:transparent; color:#e5e7eb; border:none; width:120px; font-weight:600; font-size:12px }
    .tab .x { font-weight:800; color:#94a3b8; cursor:pointer }
    .wrap { padding:16px; display:flex; justify-content:center }
    .container { width:100%; max-width:980px; }
    .card { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:12px }
    .controls { display:flex; gap:12px; align-items:center; justify-content:space-between; margin-bottom:10px; flex-wrap:wrap; font-size:12px }
    .right { display:flex; gap:8px; align-items:center; flex-wrap:wrap }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace }
    .units { display:grid; grid-template-columns: repeat(6, minmax(120px, 1fr)); gap:8px; margin:10px 0 6px }
    .units label { display:flex; flex-direction:column; gap:4px; font-size:11px; color:var(--muted) }
    select, input[type="number"] { background:#0b1220; color:#e5e7eb; border:1px solid var(--border); border-radius:8px; padding:6px 8px; font-size:12px }
    input[type="number"] { width:72px }
    table { width:100%; border-collapse:collapse; table-layout:fixed }
    thead th { position:sticky; top:0; background:#0b1220; z-index:1 }
    th,td { border:1px solid #1f2937; padding:6px; text-align:left; vertical-align:top; font-size:12px; line-height:1.2 }
    td[contenteditable="true"] { outline:none }
    td:focus { box-shadow: inset 0 0 0 2px var(--accent) }
    .plot-title { font-size:12px; color:var(--muted); margin-bottom:8px }
    .plot-wrap { width:100%; overflow:auto }
    .plot-empty { font-size:12px; color:var(--muted); padding:8px }
    .diag { font-size:12px; color:#eab308; }
    .diag .ok { color:#22c55e }
    .diag .bad { color:#f87171 }
    .diag ul { margin:6px 0 0 18px; padding:0 }
    .legend { display:flex; gap:12px; align-items:center; margin-top:6px; font-size:11px; color:#cbd5e1 }
    .legend .item { display:flex; gap:6px; align-items:center }
    .chip { width:14px; height:3px; border-radius:2px; display:inline-block }
  </style>
</head>
<body>
  <header>
    <div class="brandwrap">
      <div class="title">IXFM Decline Curve Generator</div>
      <div class="subtitle">Prototype Version</div>
    </div>
    <button class="btn dark" id="addWellBtn">+ Add Well</button>
    <button class="btn brand" id="downloadBtn">Download JSON</button>
    <button class="btn danger" id="deleteAllBtn">Delete All Wells</button>
    <span class="hint">Tip: paste from Excel; rows auto-expand.</span>
  </header>

  <div class="tabs" id="tabs"></div>

  <div class="wrap">
    <div class="container">
      <div class="card">
        <div class="controls">
          <div class="mono">Active: <span id="activeWellName"></span></div>
          <div class="right">
            <label class="hint">Copies</label>
            <input id="copyCount" type="number" min="1" step="1" value="1" />
            <button class="btn dark" id="duplicateBtn">Duplicate</button>
            <button class="btn dark" id="clearDataBtn">Clear Data</button>
            <button class="btn danger" id="deleteWellBtn">Delete Well</button>
          </div>
        </div>

        <div class="units">
          <label title="Time in days since start">
            Time Unit
            <select id="u_time">
              <option value="d">days</option>
              <option value="h">hours</option>
              <option value="mo30">months (30 d)</option>
              <option value="y365">years (365 d)</option>
            </select>
          </label>
          <label title="WBP9: 9-point well-block average pressure near the well">
            Block P Unit
            <select id="u_bp">
              <option value="kpa">kPa</option>
              <option value="bar">bar</option>
              <option value="mpa">MPa</option>
              <option value="psi">psi</option>
            </select>
          </label>
          <label title="WBHP: flowing bottom-hole pressure (reference depth)">
            BHP Unit
            <select id="u_bhp">
              <option value="kpa">kPa</option>
              <option value="bar">bar</option>
              <option value="mpa">MPa</option>
              <option value="psi">psi</option>
            </select>
          </label>
          <label title="WOPR: oil production rate at surface conditions">
            Oil Rate Unit
            <select id="u_oil">
              <option value="m3d">m³/day</option>
              <option value="stbd">STB/day</option>
              <option value="m3h">m³/hour</option>
            </select>
          </label>
          <label title="WGPR: gas production rate at surface conditions">
            Gas Rate Unit
            <select id="u_gas">
              <option value="m3d">m³/day</option>
              <option value="mscf">MSCF/day</option>
              <option value="mmscf">MMSCF/day</option>
            </select>
          </label>
          <label title="WWPR: water production rate at surface conditions">
            Water Rate Unit
            <select id="u_wat">
              <option value="m3d">m³/day</option>
              <option value="stbd">STB/day</option>
              <option value="m3h">m³/hour</option>
            </select>
          </label>
        </div>

        <div style="overflow:auto;">
          <table>
            <thead>
              <tr>
                <th title="Time in days since start">Time</th>
                <th title="WBP9: well-block pressure near the well">Well Block Pressure - 9P</th>
                <th title="WBHP: flowing bottom-hole pressure">Bottom-hole Pressure</th>
                <th title="WOPR: oil production rate (surface)">Oil Rate</th>
                <th title="WGPR: gas production rate (surface)">Gas Rate</th>
                <th title="WWPR: water production rate (surface)">Water Rate</th>
              </tr>
            </thead>
            <tbody id="tableBody"></tbody>
          </table>
        </div>
      </div>

      <div class="card" style="margin-top:12px;">
        <div class="legend mono">
          <div class="item"><span class="chip" style="background:#3b82f6"></span>Raw</div>
          <div class="item"><span class="chip" style="background:#a78bfa"></span>Reconstructed (TLS)</div>
        </div>
      </div>

      <div class="card" style="margin-top:12px;">
        <div class="plot-title mono">Intercept (q @ pwf=0) vs Days — STB/d</div>
        <div class="plot-wrap">
          <svg id="plotIntercept" width="100%" height="280" viewBox="0 0 900 280" preserveAspectRatio="none"></svg>
          <div id="emptyIntercept" class="plot-empty" style="display:none;">Enter at least two valid rows (Time, BP, BHP, Oil).</div>
        </div>
      </div>

      <div class="card" style="margin-top:12px;">
        <div class="plot-title mono">IPR (Productivity Index) vs Days — (STB/d)/psi</div>
        <div class="plot-wrap">
          <svg id="plotPI" width="100%" height="280" viewBox="0 0 900 280" preserveAspectRatio="none"></svg>
          <div id="emptyPI" class="plot-empty" style="display:none;">Enter at least two valid rows (Time, BP, BHP, Oil).</div>
        </div>
      </div>

      <div class="card" style="margin-top:12px;">
        <div class="plot-title mono">IPR vs Intercept — Scatter (raw vs TLS recon)</div>
        <div class="plot-wrap">
          <svg id="plotPIvsInt" width="100%" height="300" viewBox="0 0 900 300" preserveAspectRatio="none"></svg>
          <div id="emptyPIvsInt" class="plot-empty" style="display:none;">Enter at least two valid rows (Time, BP, BHP, Oil).</div>
        </div>
      </div>

      <div class="card" style="margin-top:12px;">
        <div class="plot-title mono">Diagnostics — Sanity Checks (Darcy IPR)</div>
        <div class="diag" id="diagBox">
          <span class="ok">No issues yet.</span>
        </div>
      </div>
    </div>
  </div>

<script>
/** Constants & state */
const WELL_COLS = ["Time","Well Block Pressure - 9P","Bottom-hole Pressure","Oil Rate","Gas Rate","Water Rate"];
const SERIES_META = {
  OIL_PRODUCTION_CUML: { description:"Oil production cumulative rate", displayUnit:"STB", measurementID:"Liquid_Production_Volume" },
  GAS_OIL_RATIO: { description:"Gas Oil Ratio", displayUnit:"MSCF/STB", measurementID:"Gas_To_Liquid_Ratio" },
  WATER_CUT: { description:"Water Cut", displayUnit:"STB/STB", measurementID:"Liquid_To_Liquid_Ratio" },
  INTERCEPT_OIL_PHASE_IPR_REF_DEPTH: { description:"Oil phase IPR intercept", displayUnit:"STB/d", measurementID:"Liquid_Flowrate" },
  SCALING_FACTOR_OIL_PHASE_IPR_REF_DEPTH: { description:"Oil phase IPR scaling factor (PI)", displayUnit:"(STB/d)/psi", measurementID:"Liquid_Productivity_Index" }
};
const M3_TO_STB = 6.28981077;
const STB_TO_M3 = 1 / M3_TO_STB;
const M3_TO_MMSCF = 0.0000353146667;
const PSI_TO_KPA = 6.894757293168;
const BAR_TO_KPA = 100.0;
const MPA_TO_KPA = 1000.0;

let wells = [];
let activeWellId = null;

/** DOM refs */
const tabsEl = document.getElementById('tabs');
const bodyEl = document.getElementById('tableBody');
const addWellBtn = document.getElementById('addWellBtn');
const downloadBtn = document.getElementById('downloadBtn');
const deleteAllBtn = document.getElementById('deleteAllBtn');
const deleteWellBtn = document.getElementById('deleteWellBtn');
const clearDataBtn = document.getElementById('clearDataBtn');
const duplicateBtn = document.getElementById('duplicateBtn');
const copyCountInput = document.getElementById('copyCount');
const activeWellNameEl = document.getElementById('activeWellName');
const u_time = document.getElementById('u_time');
const u_bp = document.getElementById('u_bp');
const u_bhp = document.getElementById('u_bhp');
const u_oil = document.getElementById('u_oil');
const u_gas = document.getElementById('u_gas');
const u_wat = document.getElementById('u_wat');
const svgIntercept = document.getElementById('plotIntercept');
const svgPI = document.getElementById('plotPI');
const svgPIvsInt = document.getElementById('plotPIvsInt');
const emptyIntercept = document.getElementById('emptyIntercept');
const emptyPI = document.getElementById('emptyPI');
const emptyPIvsInt = document.getElementById('emptyPIvsInt');
const diagBox = document.getElementById('diagBox');

/** Helpers */
const uuid = () => Math.random().toString(36).slice(2,9);
const toNumber = v => {
  if (typeof v === 'number') return v;
  if (v == null) return NaN;
  const s = String(v).trim().replace(/,/g,'');
  if (s === '') return NaN;
  const n = Number(s);
  return Number.isFinite(n) ? n : NaN;
};
const isMostlyNonNumericRow = row => row.map(toNumber).filter(Number.isFinite).length <= 2;
function ensureRows(well, rowsNeeded) { const add = Math.max(0, rowsNeeded - well.tableData.length); for (let i=0;i<add;i++) well.tableData.push(Array(WELL_COLS.length).fill('')); return add; }
function isWellEmpty(well) { for (const row of well.tableData) for (const cell of row) if (String(cell ?? '').trim() !== '') return false; return true; }
function nextAvailableWellName() {
  const used = new Set(); for (const w of wells) { const m = /^P(\d+)$/.exec(w.name.trim()); if (m) used.add(Number(m[1])); }
  let n = 1; while (used.has(n)) n++; return `P${n}`;
}

/** Units */
function factorTimeToDays(code){ switch(code){ case 'd': return 1; case 'h': return 1/24; case 'mo30': return 30; case 'y365': return 365; default: return 1; } }
function factorPressureToKPa(code){ switch(code){ case 'kpa': return 1; case 'bar': return BAR_TO_KPA; case 'mpa': return MPA_TO_KPA; case 'psi': return PSI_TO_KPA; default: return 1; } }
function factorOilWaterToM3d(code){ switch(code){ case 'm3d': return 1; case 'stbd': return STB_TO_M3; case 'm3h': return 24; default: return 1; } }
function factorGasToM3d(code){ switch(code){ case 'm3d': return 1; case 'mscf': return 28.316846592; case 'mmscf': return 28316.846592; default: return 1; } }
function applyFactorArray(arr, factor){ return arr.map(v => Number.isFinite(v) ? v*factor : NaN); }

/** Tabs & wells */
function defaultUnits(){ return { time:'d', bp:'kpa', bhp:'kpa', oil:'m3d', gas:'m3d', wat:'m3d' }; }
function createWell(name){ return { id: uuid(), name, units: defaultUnits(), tableData: Array.from({length:30}, () => Array(WELL_COLS.length).fill('')) }; }
function addWell(initialName) { const name = initialName ?? `P${wells.length+1}`; const well = createWell(name); wells.push(well); setActiveWell(well.id); renderTabs(); renderTable(); renderUnits(); renderAllPlotsAndDiag(); }
function deleteWell(id) { wells = wells.filter(w=>w.id!==id); if (!wells.length) addWell('P1'); setActiveWell(wells[0].id); renderTabs(); renderTable(); renderUnits(); renderAllPlotsAndDiag(); }
function deleteWellWithMaybeConfirm(id) { const w = wells.find(x=>x.id===id); if (!w) return; if (isWellEmpty(w)) { deleteWell(id); } else { if (confirm(`Delete well "${w.name}"?`)) deleteWell(id); } }
function resetAllWells() { wells = []; addWell('P1'); }
function setActiveWell(id) { activeWellId = id; activeWellNameEl.textContent = wells.find(w=>w.id===id)?.name ?? ''; }
function renameWell(id,newName) { const w = wells.find(x=>x.id===id); if (!w) return; w.name = newName.trim() || w.name; if (id===activeWellId) activeWellNameEl.textContent = w.name; }
function renderTabs() {
  const tabsElLoc = tabsEl;
  tabsElLoc.innerHTML = '';
  wells.forEach(w=>{
    const tab=document.createElement('div');
    tab.className='tab'+(w.id===activeWellId?' active':''); 
    tab.onclick=()=>{ setActiveWell(w.id); renderTabs(); renderTable(); renderUnits(); renderAllPlotsAndDiag(); };
    const input=document.createElement('input'); input.value=w.name; input.oninput=e=>renameWell(w.id,e.target.value);
    const close=document.createElement('span'); close.className='x'; close.textContent='×'; close.onclick=(ev)=>{ ev.stopPropagation(); deleteWellWithMaybeConfirm(w.id); };
    tab.appendChild(input); tab.appendChild(close); tabsElLoc.appendChild(tab);
  });
}

/** Table */
function renderTable() {
  const w = wells.find(x=>x.id===activeWellId); if (!w) return;
  bodyEl.innerHTML='';
  w.tableData.forEach((row,r)=>{
    const tr=document.createElement('tr');
    for (let c=0;c<WELL_COLS.length;c++){
      const td=document.createElement('td');
      td.contentEditable='true'; td.spellcheck=false;
      td.dataset.row=r; td.dataset.col=c;
      td.textContent=row[c] ?? '';
      td.addEventListener('input', onCellInput);
      td.addEventListener('paste', onCellPaste);
      tr.appendChild(td);
    }
    bodyEl.appendChild(tr);
  });
}
function onCellInput(e){
  const td=e.currentTarget; const r=+td.dataset.row, c=+td.dataset.col;
  const w=wells.find(x=>x.id===activeWellId);
  w.tableData[r][c]=td.textContent;
  renderAllPlotsAndDiag();
}
function onCellPaste(e){
  e.preventDefault();
  const td=e.currentTarget; const startR=+td.dataset.row, startC=+td.dataset.col;
  const raw=(e.clipboardData||window.clipboardData).getData('text');
  const lines=raw.replace(/\r/g,'').split('\n').filter(Boolean).map(l=>l.split('\t'));
  if (!lines.length) return;
  const payload=isMostlyNonNumericRow(lines[0])?lines.slice(1):lines;
  const w=wells.find(x=>x.id===activeWellId);
  const added=ensureRows(w, startR+payload.length);
  if (added>0) renderTable();
  for (let i=0;i<payload.length;i++){
    const cols=payload[i];
    for (let j=0;j<cols.length && (startC+j)<WELL_COLS.length;j++){
      const r=startR+i, c=startC+j;
      w.tableData[r][c]=cols[j];
      const cell=bodyEl.querySelector(`td[data-row="${r}"][data-col="${c}"]`);
      if (cell) cell.textContent=cols[j];
    }
  }
  renderAllPlotsAndDiag();
}

/** Math utils */
function safeDiv(a,b){ return (Number.isFinite(a)&&Number.isFinite(b)&&Math.abs(b)>0)?(a/b):NaN; }
function cumsum(arr){ const out=[]; let s=0; for (const v of arr){ const x=Number.isFinite(v)?v:0; s+=x; out.push(s) } return out; }
const clamp01 = (x)=> Math.max(0, Math.min(1, x));

/** TLS fit helpers */
function tlsFit(xs, ys){
  const n = xs.length;
  if (n < 2) return null;
  let mx=0, my=0;
  for (let i=0;i<n;i++){ mx += xs[i]; my += ys[i]; }
  mx /= n; my /= n;
  let sxx=0, syy=0, sxy=0;
  for (let i=0;i<n;i++){
    const dx = xs[i]-mx, dy = ys[i]-my;
    sxx += dx*dx; syy += dy*dy; sxy += dx*dy;
  }
  sxx /= n; syy /= n; sxy /= n;
  const theta = 0.5 * Math.atan2(2*sxy, sxx - syy);
  const ux = Math.cos(theta), uy = Math.sin(theta);
  return { mx, my, ux, uy };
}
function tlsProjectPoint(fit, x, y){
  const dx = x - fit.mx, dy = y - fit.my;
  const t = fit.ux*dx + fit.uy*dy;
  return [ fit.mx + t*fit.ux, fit.my + t*fit.uy ];
}
function tlsYgivenX(fit, x){
  const EPS = 1e-12;
  if (!fit) return NaN;
  if (Math.abs(fit.ux) < EPS) return fit.my;
  const m = fit.uy / fit.ux;
  const b = fit.my - m*fit.mx;
  return m*x + b;
}

/** Core computation */
function computeWellSeriesPhysical(well){
  const data = well.tableData;
  const DAYS_raw = data.map(r=>toNumber(r[0]));
  const BP_raw   = data.map(r=>toNumber(r[1]));
  const BHP_raw  = data.map(r=>toNumber(r[2]));
  const OIL_raw  = data.map(r=>toNumber(r[3]));
  const GAS_raw  = data.map(r=>toNumber(r[4]));
  const WAT_raw  = data.map(r=>toNumber(r[5]));

  let L = DAYS_raw.length;
  for (; L>0; L--){
    const i=L-1;
    if ([DAYS_raw[i],BP_raw[i],BHP_raw[i],OIL_raw[i],GAS_raw[i],WAT_raw[i]].some(v=>Number.isFinite(v))) break;
  }
  if (L===0) return null;

  const fTime = factorTimeToDays(well.units.time);
  const fBP = factorPressureToKPa(well.units.bp);
  const fBHP = factorPressureToKPa(well.units.bhp);
  const fOil = factorOilWaterToM3d(well.units.oil);
  const fGas = factorGasToM3d(well.units.gas);
  const fWat = factorOilWaterToM3d(well.units.wat);

  const Days = applyFactorArray(DAYS_raw.slice(0,L), fTime);
  const BP_kPa = applyFactorArray(BP_raw.slice(0,L), fBP);
  const BHP_kPa = applyFactorArray(BHP_raw.slice(0,L), fBHP);
  const OIL_m3d = applyFactorArray(OIL_raw.slice(0,L), fOil);
  const GAS_m3d = applyFactorArray(GAS_raw.slice(0,L), fGas);
  const WAT_m3d = applyFactorArray(WAT_raw.slice(0,L), fWat);

  const oil_stb = OIL_m3d.map(v=>Number.isFinite(v)? Math.max(0, v*6.28981077) : NaN);
  const wat_stb = WAT_m3d.map(v=>Number.isFinite(v)? Math.max(0, v*6.28981077) : NaN);
  const gas_mmscf = GAS_m3d.map(v=>Number.isFinite(v)? Math.max(0, v*0.0000353146667) : NaN);
  const BP_psi = BP_kPa.map(v=>Number.isFinite(v)? v/6.894757293168 : NaN);
  const BHP_psi = BHP_kPa.map(v=>Number.isFinite(v)? v/6.894757293168 : NaN);

  const GOR = oil_stb.map((o,i)=>safeDiv(gas_mmscf[i], o));
  const WATER_FRAC = oil_stb.map((o,i)=>{
    const w = wat_stb[i];
    const denom = (Number.isFinite(o)?o:0) + (Number.isFinite(w)?w:0);
    return denom > 0 ? safeDiv(w, denom) : NaN;
  });

  const dDays = Days.map(v=>Number.isFinite(v)?v:0);
  for (let i=dDays.length-1;i>=1;i--) dDays[i] = (Number.isFinite(Days[i])?Days[i]:0) - (Number.isFinite(Days[i-1])?Days[i-1]:0);
  const oilVolPerDate = oil_stb.map((q,i)=>(Number.isFinite(q)?q:0) * (Number.isFinite(dDays[i])?dDays[i]:0));
  const CumOil = cumsum(oilVolPerDate);

  const dP = BP_psi.map((bp,i)=>{
    const pwf = BHP_psi[i];
    return (Number.isFinite(bp) && Number.isFinite(pwf)) ? Math.max(0, bp - pwf) : NaN;
  });

  let PI = oil_stb.map((q,i)=> {
    const dp = dP[i];
    const val = safeDiv(q, dp);
    return Number.isFinite(val) ? Math.max(0, val) : NaN;
  });
  if (PI.length >= 2 && !Number.isFinite(PI[0]) && Number.isFinite(PI[1])) PI[0] = PI[1];

  let INTERCEPT_DARCY = PI.map((pi,i)=>{
    const bp = BP_psi[i];
    const val = (Number.isFinite(pi) && Number.isFinite(bp)) ? (pi * bp) : NaN;
    return Number.isFinite(val) ? Math.max(0, val) : NaN;
  });
  if (INTERCEPT_DARCY.length>=2 && !Number.isFinite(INTERCEPT_DARCY[0]) && Number.isFinite(INTERCEPT_DARCY[1])) {
    INTERCEPT_DARCY[0] = INTERCEPT_DARCY[1];
  }

  // TLS fit for (Intercept vs PI)
  const EPS_Q = 1e-9, EPS_DP = 1e-6;
  const fitXs = [], fitYs = [];
  for (let i=0;i<L;i++){
    const xi = INTERCEPT_DARCY[i];
    const yi = PI[i];
    if (!Number.isFinite(xi) || !Number.isFinite(yi)) continue;
    const q = oil_stb[i];
    const dp = dP[i];
    if (i===0 && Number.isFinite(q) && Math.abs(q) <= EPS_Q) continue; // avoid zero-flow first row
    if (Number.isFinite(dp) && Math.abs(dp) <= EPS_DP) continue;       // unstable Δp
    fitXs.push(xi);
    fitYs.push(yi);
  }
  let fit = null;
  if (fitXs.length >= 2) fit = tlsFit(fitXs, fitYs);

  let INTERCEPT_TLS = INTERCEPT_DARCY.slice();
  let PI_TLS = PI.slice();
  if (fit){
    for (let i=0;i<L;i++){
      const xi = INTERCEPT_DARCY[i];
      const yi = PI[i];
      if (!Number.isFinite(xi) || !Number.isFinite(yi)) continue;
      if (i===0 && Number.isFinite(oil_stb[0]) && Math.abs(oil_stb[0])<=EPS_Q) continue;
      const pr = tlsProjectPoint(fit, xi, yi);
      INTERCEPT_TLS[i] = pr[0];
      PI_TLS[i] = pr[1];
    }
    if (Number.isFinite(oil_stb[0]) && Math.abs(oil_stb[0])<=EPS_Q){
      const xs = INTERCEPT_TLS.filter(Number.isFinite);
      const xMax = xs.length ? Math.max.apply(null, xs) : INTERCEPT_DARCY[0];
      const yAtXmax = tlsYgivenX(fit, xMax);
      if (Number.isFinite(xMax)) INTERCEPT_TLS[0] = xMax;
      if (Number.isFinite(yAtXmax)) PI_TLS[0] = Math.max(0, yAtXmax);
    }
  }

  const sanitize = a => a.map(v=>Number.isFinite(v)?v:0);

  return {
    name: well.name.replace(/\./g,''),
    length: L,
    OIL_PRODUCTION_CUML: sanitize(CumOil),
    GAS_OIL_RATIO: sanitize(GOR),
    WATER_CUT: sanitize(WATER_FRAC),
    INTERCEPT_OIL_PHASE_IPR_REF_DEPTH: sanitize(INTERCEPT_TLS),
    SCALING_FACTOR_OIL_PHASE_IPR_REF_DEPTH: sanitize(PI_TLS),
    __plot: {
      Days,
      InterceptDarcy: INTERCEPT_DARCY.slice(),
      InterceptRecon: INTERCEPT_TLS.slice(),
      PI: PI.slice(),
      PIRecon: PI_TLS.slice(),
      BP_psi: BP_psi.slice(),
      BHP_psi: BHP_psi.slice(),
      q_stbd: oil_stb.slice()
    }
  };
}

/** Export JSON */
function buildJson(){
  const payload = { name:"IPR Decline Curves", series:[], step:{}, unitSystem:"ECLIPSE_FIELD", version:"v1" };
  for (const w of wells){
    const c = computeWellSeriesPhysical(w);
    if (!c) continue;
    payload.step[c.name] = Array.from({length:c.length}, (_,i)=>i);
    const order = ["OIL_PRODUCTION_CUML","GAS_OIL_RATIO","WATER_CUT","INTERCEPT_OIL_PHASE_IPR_REF_DEPTH","SCALING_FACTOR_OIL_PHASE_IPR_REF_DEPTH"];
    for (const key of order){
      // Force last value to zero for the two requested series (export-only override).
      let values = c[key];
      if (key === "INTERCEPT_OIL_PHASE_IPR_REF_DEPTH" || key === "SCALING_FACTOR_OIL_PHASE_IPR_REF_DEPTH") {
        values = c[key].slice();
        if (values.length > 0) values[values.length - 1] = 0; // ensure tail is zero
      }
      payload.series.push({
        description: SERIES_META[key].description,
        displayUnit: SERIES_META[key].displayUnit,
        entityName: c.name,
        entityType: "WELL",
        measurementID: SERIES_META[key].measurementID,
        name: key,
        values
      });
    }
  }
  return payload;
}
function download(filename, obj){
  const blob=new Blob([JSON.stringify(obj,null,2)],{type:"application/json"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download=filename; document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}

/** Duplicate */
function duplicateActiveWell(copies) {
  const src = wells.find(x=>x.id===activeWellId);
  if (!src) return;
  const count = Math.max(1, Math.floor(copies || 1));
  for (let i=0;i<count;i++) {
    const name = nextAvailableWellName();
    const id = uuid();
    const tableCopy = src.tableData.map(row => row.slice());
    const unitsCopy = { ...src.units };
    wells.push({ id, name, tableData: tableCopy, units: unitsCopy });
  }
  renderTabs(); renderAllPlotsAndDiag();
}

/** Plotting */
function clearSVG(svg){ while (svg.firstChild) svg.removeChild(svg.firstChild); }
function makeSVG(tag){ return document.createElementNS('http://www.w3.org/2000/svg', tag); }

function renderLineMulti(svg, seriesList, {xLabel, yLabel, emptyEl}){
  clearSVG(svg);
  const allPts = seriesList.flatMap(s=>s.pts);
  if (!allPts.length || allPts.length < 2) { if (emptyEl) emptyEl.style.display='block'; return; }
  if (emptyEl) emptyEl.style.display='none';

  const wBox = svg.viewBox.baseVal.width || 900, hBox = svg.viewBox.baseVal.height || 280;
  const margin = {left:60, right:16, top:16, bottom:36};
  const W = wBox - margin.left - margin.right;
  const H = hBox - margin.top - margin.bottom;

  const xMin = 0;
  const xMax = Math.max(...allPts.map(p=>p[0])) || 1;
  const yMin = 0;
  const yMaxRaw = Math.max(...allPts.map(p=>p[1])) || 1;
  const yMax = (yMaxRaw<=0?1:yMaxRaw*1.1);

  const xMap = x => margin.left + (xMax===xMin?0:((x-xMin)/(xMax-xMin)))*W;
  const yMap = y => margin.top + H - (yMax===yMin?0:((y-yMin)/(yMax-yMin)))*H;

  const axes = makeSVG('g');
  const xAxis = makeSVG('line'); xAxis.setAttribute('x1', margin.left); xAxis.setAttribute('y1', margin.top+H); xAxis.setAttribute('x2', margin.left+W); xAxis.setAttribute('y2', margin.top+H); xAxis.setAttribute('stroke', '#2f3b52'); axes.appendChild(xAxis);
  const yAxis = makeSVG('line'); yAxis.setAttribute('x1', margin.left); yAxis.setAttribute('y1', margin.top); yAxis.setAttribute('x2', margin.left); yAxis.setAttribute('y2', margin.top+H); yAxis.setAttribute('stroke', '#2f3b52'); axes.appendChild(yAxis);

  const xticks=5, yticks=5;
  for (let i=0;i<=xticks;i++){
    const v = xMin + (i/xticks)*(xMax-xMin);
    const x = xMap(v);
    const t = makeSVG('line'); t.setAttribute('x1',x); t.setAttribute('y1',margin.top+H); t.setAttribute('x2',x); t.setAttribute('y2',margin.top+H+6); t.setAttribute('stroke','#2f3b52'); axes.appendChild(t);
    const lbl = makeSVG('text'); lbl.setAttribute('x',x); lbl.setAttribute('y',margin.top+H+20); lbl.setAttribute('text-anchor','middle'); lbl.setAttribute('font-size','11'); lbl.setAttribute('fill','#94a3b8'); lbl.textContent = (Math.round(v*100)/100).toString(); axes.appendChild(lbl);
  }
  for (let i=0;i<=yticks;i++){
    const v = yMin + (i/yticks)*(yMax-yMin);
    const y = yMap(v);
    const t = makeSVG('line'); t.setAttribute('x1',margin.left-6); t.setAttribute('y1',y); t.setAttribute('x2',margin.left); t.setAttribute('y2',y); t.setAttribute('stroke','#2f3b52'); axes.appendChild(t);
    const g = makeSVG('line'); g.setAttribute('x1',margin.left); g.setAttribute('y1',y); g.setAttribute('x2',margin.left+W); g.setAttribute('y2',y); g.setAttribute('stroke','#1f2937'); axes.appendChild(g);
    const lbl = makeSVG('text'); lbl.setAttribute('x',margin.left-8); lbl.setAttribute('y',y+4); lbl.setAttribute('text-anchor','end'); lbl.setAttribute('font-size','11'); lbl.setAttribute('fill','#94a3b8'); lbl.textContent = Math.round(v).toString(); axes.appendChild(lbl);
  }

  const xlab = makeSVG('text'); xlab.setAttribute('x', margin.left+W/2); xlab.setAttribute('y', margin.top+H+32); xlab.setAttribute('text-anchor','middle'); xlab.setAttribute('font-size','12'); xlab.setAttribute('fill','#cbd5e1'); xlab.textContent = xLabel; axes.appendChild(xlab);
  const ylab = makeSVG('text'); ylab.setAttribute('x', 12); ylab.setAttribute('y', margin.top+H/2); ylab.setAttribute('transform', `rotate(-90 12 ${margin.top+H/2})`); ylab.setAttribute('text-anchor','middle'); ylab.setAttribute('font-size','12'); ylab.setAttribute('fill','#cbd5e1'); ylab.textContent = yLabel; axes.appendChild(ylab);

  svg.appendChild(axes);

  for (const s of seriesList){
    if (!s.pts.length) continue;
    const d = s.pts.map((p,i)=>`${i?'L':'M'} ${xMap(p[0])} ${yMap(p[1])}`).join(' ');
    const path = makeSVG('path');
    path.setAttribute('d', d);
    path.setAttribute('fill','none');
    path.setAttribute('stroke', s.color || '#3b82f6');
    path.setAttribute('stroke-width','2');
    if (s.dash) path.setAttribute('stroke-dasharray', s.dash);
    svg.appendChild(path);
  }
}

function renderScatterMulti(svg, seriesList, {xLabel, yLabel, emptyEl}){
  clearSVG(svg);
  const allPts = seriesList.flatMap(s=>s.pts);
  if (!allPts.length || allPts.length < 2) { if (emptyEl) emptyEl.style.display='block'; return; }
  if (emptyEl) emptyEl.style.display='none';

  const wBox = svg.viewBox.baseVal.width || 900, hBox = svg.viewBox.baseVal.height || 300;
  const margin = {left:70, right:16, top:16, bottom:42};
  const W = wBox - margin.left - margin.right;
  const H = hBox - margin.top - margin.bottom;

  const xMin = 0, xMax = Math.max(...allPts.map(p=>p[0])) || 1;
  const yMin = 0, yMax = Math.max(...allPts.map(p=>p[1])) || 1;
  const xMap = x => margin.left + (xMax===xMin?0:((x-xMin)/(xMax-xMin)))*W;
  const yMap = y => margin.top + H - (yMax===yMin?0:((y-yMin)/(yMax-yMin)))*H;

  const axes = makeSVG('g');
  const xAxis = makeSVG('line'); xAxis.setAttribute('x1',margin.left); xAxis.setAttribute('y1',margin.top+H); xAxis.setAttribute('x2',margin.left+W); xAxis.setAttribute('y2',margin.top+H); xAxis.setAttribute('stroke','#2f3b52'); axes.appendChild(xAxis);
  const yAxis = makeSVG('line'); yAxis.setAttribute('x1',margin.left); yAxis.setAttribute('y1',margin.top); yAxis.setAttribute('x2',margin.left); yAxis.setAttribute('y2',margin.top+H); yAxis.setAttribute('stroke','#2f3b52'); axes.appendChild(yAxis);

  const xticks=5, yticks=5;
  for (let i=0;i<=xticks;i++){
    const v = xMin + (i/xticks)*(xMax-xMin);
    const x = xMap(v);
    const t = makeSVG('line'); t.setAttribute('x1',x); t.setAttribute('y1',margin.top+H); t.setAttribute('x2',x); t.setAttribute('y2',margin.top+H+6); t.setAttribute('stroke','#2f3b52'); axes.appendChild(t);
    const lbl = makeSVG('text'); lbl.setAttribute('x',x); lbl.setAttribute('y',margin.top+H+24); lbl.setAttribute('text-anchor','middle'); lbl.setAttribute('font-size','11'); lbl.setAttribute('fill','#94a3b8'); lbl.textContent = Math.round(v).toString(); axes.appendChild(lbl);
  }
  for (let i=0;i<=yticks;i++){
    const v = yMin + (i/yticks)*(yMax-yMin);
    const y = yMap(v);
    const t = makeSVG('line'); t.setAttribute('x1',margin.left-6); t.setAttribute('y1',y); t.setAttribute('x2',margin.left); t.setAttribute('y2',y); t.setAttribute('stroke','#2f3b52'); axes.appendChild(t);
    const g = makeSVG('line'); g.setAttribute('x1',margin.left); g.setAttribute('y1',y); g.setAttribute('x2',margin.left+W); g.setAttribute('y2',y); g.setAttribute('stroke','#1f2937'); axes.appendChild(g);
    const lbl = makeSVG('text'); lbl.setAttribute('x',margin.left-8); lbl.setAttribute('y',y+4); lbl.setAttribute('text-anchor','end'); lbl.setAttribute('font-size','11'); lbl.setAttribute('fill','#94a3b8'); lbl.textContent = (Math.round(v*1000)/1000).toString(); axes.appendChild(lbl);
  }

  const xlab = makeSVG('text'); xlab.setAttribute('x', margin.left+W/2); xlab.setAttribute('y', margin.top+H+36); xlab.setAttribute('text-anchor','middle'); xlab.setAttribute('font-size','12'); xlab.setAttribute('fill','#cbd5e1'); xlab.textContent = xLabel; axes.appendChild(xlab);
  const ylab = makeSVG('text'); ylab.setAttribute('x', 14); ylab.setAttribute('y', margin.top+H/2); ylab.setAttribute('transform', `rotate(-90 14 ${margin.top+H/2})`); ylab.setAttribute('text-anchor','middle'); ylab.setAttribute('font-size','12'); ylab.setAttribute('fill','#cbd5e1'); ylab.textContent = yLabel; axes.appendChild(ylab);

  svg.appendChild(axes);

  for (const s of seriesList){
    for (const [xv,yv] of s.pts){
      if (!Number.isFinite(xv) || !Number.isFinite(yv)) continue;
      const c = makeSVG('circle');
      c.setAttribute('cx', xMap(xv));
      c.setAttribute('cy', yMap(yv));
      c.setAttribute('r', 3.2);
      c.setAttribute('fill', s.color || '#3b82f6');
      svg.appendChild(c);
    }
  }
}

/** Diagnostics (Darcy) */
function buildDiagnostics(plot){
  const msgs = [];
  const tolRel = 0.05;
  const {Days, InterceptDarcy, PI, BP_psi, BHP_psi, q_stbd} = plot;

  for (let i=0;i<Days.length;i++){
    const day = Days[i];
    const bp = BP_psi[i], bhp = BHP_psi[i];
    const q = q_stbd[i], pi = PI[i], itc = InterceptDarcy[i];
    if (![bp,bhp,q].every(Number.isFinite)) continue;

    const dp = Math.max(0, bp - bhp);
    if (bp < bhp) msgs.push(`t=${day}: BP < BHP → Δp<0 (check pressures).`);

    if (Number.isFinite(pi) && Number.isFinite(bp) && Number.isFinite(itc)){
      const expect = pi*bp, denom = Math.max(1, Math.abs(itc));
      const rel = Math.abs(itc - expect) / denom;
      if (rel > tolRel) msgs.push(`t=${day}: Intercept mismatch (>5%). I=${itc.toFixed(2)}, PI*BP=${expect.toFixed(2)}.`);
    }

    if (Number.isFinite(q) && Number.isFinite(itc) && q > itc*(1+tolRel))
      msgs.push(`t=${day}: q (${q.toFixed(2)}) > Intercept (${itc.toFixed(2)}).`);

    if (dp < 1e-6 && q > 0) msgs.push(`t=${day}: Δp≈0 but q>0 (check BHP/BP).`);

    if ((!Number.isFinite(pi) || pi===0) && q>0 && dp>0)
      msgs.push(`t=${day}: PI≈0 but q>0 and Δp>0 (check units).`);
  }
  return msgs;
}

/** Render all outputs */
function renderAllPlotsAndDiag(){
  const w = wells.find(x=>x.id===activeWellId);
  clearSVG(svgIntercept); clearSVG(svgPI); clearSVG(svgPIvsInt);
  if (!w) return;

  const comp = computeWellSeriesPhysical(w);
  if (!comp || !comp.__plot) {
    emptyIntercept.style.display='block';
    emptyPI.style.display='block';
    emptyPIvsInt.style.display='block';
    diagBox.innerHTML = `<span class="ok">No issues yet.</span>`;
    return;
  }

  const X = comp.__plot.Days || [];
  const YintD = comp.__plot.InterceptDarcy || [];
  const YintR = comp.__plot.InterceptRecon || [];
  const Ypi = comp.__plot.PI || [];
  const YpiR = comp.__plot.PIRecon || [];

  const ptsIntD = [], ptsIntRecon = [];
  const ptsPI = [], ptsPIRecon = [];
  const ptsScatterRaw = [], ptsReconScatter = [];

  for (let i=0;i<X.length; i++){
    const x = X[i];
    const itcD = YintD[i], itcR = YintR[i];
    const pi = Ypi[i], piR = YpiR[i];
    if (Number.isFinite(x) && Number.isFinite(itcD)) ptsIntD.push([x, itcD]);
    if (Number.isFinite(x) && Number.isFinite(itcR)) ptsIntRecon.push([x, itcR]);
    if (Number.isFinite(x) && Number.isFinite(pi)) ptsPI.push([x, pi]);
    if (Number.isFinite(x) && Number.isFinite(piR)) ptsPIRecon.push([x, piR]);
    if (Number.isFinite(itcD) && Number.isFinite(pi)) ptsScatterRaw.push([itcD, pi]);
    if (Number.isFinite(itcR) && Number.isFinite(piR)) ptsReconScatter.push([itcR, piR]);
  }

  const seriesInt = [
    { pts: ptsIntD, color: '#3b82f6' },
    { pts: ptsIntRecon, color: '#a78bfa' }
  ];
  renderLineMulti(svgIntercept, seriesInt, {xLabel:'Days', yLabel:'Intercept (STB/d)', emptyEl: emptyIntercept});

  const seriesPI = [
    { pts: ptsPI, color: '#3b82f6' },
    { pts: ptsPIRecon, color: '#a78bfa' }
  ];
  renderLineMulti(svgPI, seriesPI, {xLabel:'Days', yLabel:'IPR (STB/d)/psi', emptyEl: emptyPI});

  const seriesSc = [
    { pts: ptsScatterRaw, color: '#3b82f6' },
    { pts: ptsReconScatter, color: '#a78bfa' }
  ];
  renderScatterMulti(svgPIvsInt, seriesSc, {xLabel:'Intercept (STB/d)', yLabel:'IPR (STB/d)/psi', emptyEl: emptyPIvsInt});

  const diags = buildDiagnostics(comp.__plot);
  if (!diags.length){
    diagBox.innerHTML = `<span class="ok">All checks passed.</span>`;
  } else {
    const items = diags.slice(0, 30).map(m=>`<li>${m}</li>`).join('');
    diagBox.innerHTML = `<div class="bad"><b>${diags.length}</b> issue(s) detected:</div><ul>${items}</ul>`;
  }
}

/** Units wiring */
function renderUnits(){
  const w = wells.find(x=>x.id===activeWellId); if (!w) return;
  u_time.value = w.units.time;
  u_bp.value = w.units.bp;
  u_bhp.value = w.units.bhp;
  u_oil.value = w.units.oil;
  u_gas.value = w.units.gas;
  u_wat.value = w.units.wat;
}
u_time.onchange = ()=>{ const w=wells.find(x=>x.id===activeWellId); if (w) { w.units.time = u_time.value; renderAllPlotsAndDiag(); } };
u_bp.onchange = ()=>{ const w=wells.find(x=>x.id===activeWellId); if (w) { w.units.bp = u_bp.value; renderAllPlotsAndDiag(); } };
u_bhp.onchange = ()=>{ const w=wells.find(x=>x.id===activeWellId); if (w) { w.units.bhp = u_bhp.value; renderAllPlotsAndDiag(); } };
u_oil.onchange = ()=>{ const w=wells.find(x=>x.id===activeWellId); if (w) { w.units.oil = u_oil.value; renderAllPlotsAndDiag(); } };
u_gas.onchange = ()=>{ const w=wells.find(x=>x.id===activeWellId); if (w) { w.units.gas = u_gas.value; renderAllPlotsAndDiag(); } };
u_wat.onchange = ()=>{ const w=wells.find(x=>x.id===activeWellId); if (w) { w.units.wat = u_wat.value; renderAllPlotsAndDiag(); } };

/** UI actions */
document.getElementById('addWellBtn').onclick = () => addWell();
downloadBtn.onclick = () => download('ipr_decline_curves.json', buildJson());
deleteWellBtn.onclick = () => { const w=wells.find(x=>x.id===activeWellId); if (!w) return; deleteWellWithMaybeConfirm(w.id); };
deleteAllBtn.onclick = () => { if (confirm("Delete all wells and reset to P1?")) resetAllWells(); };
clearDataBtn.onclick = () => { const w=wells.find(x=>x.id===activeWellId); if (!w) return; if (!confirm(`Clear all rows for well "${w.name}"?`)) return; w.tableData = Array.from({length:30},()=>Array(WELL_COLS.length).fill('')); renderTable(); renderAllPlotsAndDiag(); };
duplicateBtn.onclick = () => { const n = Number(copyCountInput.value); duplicateActiveWell(Number.isFinite(n) ? n : 1); };

/** Boot */
addWell('P1');
</script>
</body>
</html>
